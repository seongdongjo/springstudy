//HomeController.java
package com.itbank.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HomeController {
	
	@RequestMapping("/")
	public String home() {
		return "home";
	}
}

---------------
//home.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:set var="cpath">${pageContext.request.contextPath }</c:set>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>day01</title>
</head>
<body>

<h1>컨트롤러 예제</h1>
<hr>

<ul>
	<li><a href="${pageContext.request.contextPath }/ex01">ex01 - 링크를 클릭하면 연결되는 함수</a></li>
	<li><a href="${cpath }/ex02">ex02 - 컨트롤러에 주로 사용하는 어노테이션</a></li>
	<li><a href="${cpath }/ex03">ex03 - 커맨드 객체</a></li>
	<li><a href="${cpath }/ex04">ex04 - Model And View</a></li>
	<li><a href="${cpath }/ex05">ex05 - Path Variable</a></li>
	<li><a href="${cpath }/calc">calc - 두 수의 사칙연산 계산기</a></li>
</ul>

</body>
</html>
---------------
//Ex01Controller.java
package com.itbank.controller;

import java.io.IOException;

import javax.servlet.http.HttpServletRequest;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;

/*
	스프링에서 컨트롤러의 개수는 상관이 없다
	작성자 기준으로 관련있는 주소끼리 모아서 하나의 컨트롤러로 제어하면 된다
	여러개의 컨트롤러가 있어도 서블릿의 관심사는 어떤 RequestMapping이 있는가이다
*/

@Controller
public class Ex01Controller {

	@RequestMapping(value="/ex01", method=RequestMethod.GET)
	public String ex01() {
		return "ex01";
	}
	
	// 컨트롤러는 DispatcherServlet에게 요청을 넘겨받으므로
	// DispatcherServlet이 넘겨줄 수 있는 값을 함수의 매개변수에 작성하면 된다
	@RequestMapping(value="/ex01", method=RequestMethod.POST)
	public String ex01(HttpServletRequest request) throws IOException {
		
		request.setCharacterEncoding("UTF-8");
		
		String name = request.getParameter("name");
		int age = Integer.parseInt(request.getParameter("age"));
		
		String adult = age >= 20 ? "성인" : "미성년자";
		
		request.setAttribute("name", name);
		request.setAttribute("age", age);
		request.setAttribute("adult", adult);
		
		return "ex01Result";
	}
}
-----------------
//ex01.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>ex01 (GET)</h1>
<hr>

<form method="POST">
	<input type="text" name="name" placeholder="이름을 입력하세요" required autofocus>
	<input type="number" name="age" placeholder="나이를 입력하세요" required>
	<input type="submit" value="제출">
</form>

</body>
</html>
-------------------
//ex01Result.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>ex01 (POST)</h1>
<hr>

<h3>${name }님은 ${age }살이고, ${adult }입니다</h3>

</body>
</html>

===================================================================================
//home.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:set var="cpath">${pageContext.request.contextPath }</c:set>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>day01</title>
</head>
<body>

<h1>컨트롤러 예제</h1>
<hr>

<ul>
	<li><a href="${pageContext.request.contextPath }/ex01">ex01 - 링크를 클릭하면 연결되는 함수</a></li>
	<li><a href="${cpath }/ex02">ex02 - 컨트롤러에 주로 사용하는 어노테이션</a></li>
	<li><a href="${cpath }/ex03">ex03 - 커맨드 객체</a></li>
	<li><a href="${cpath }/ex04">ex04 - Model And View</a></li>
	<li><a href="${cpath }/ex05">ex05 - Path Variable</a></li>
	<li><a href="${cpath }/calc">calc - 두 수의 사칙연산 계산기</a></li>
</ul>

</body>
</html>
--------------
//ex02.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>ex02 (GET)</h1>
<hr>

<form method="POST">
	<input type="text" name="name" placeholder="이름을 입력하세요" required autofocus>
	<input type="number" name="age" placeholder="나이를 입력하세요" required>
	<input type="submit" value="제출">
</form>

</body>
</html>
-----------------
//Ex02Controller.java
package com.itbank.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class Ex02Controller {

	//home.jsp에서 클릭하면 여기로
	@GetMapping("/ex02")	// @RequestMapping(value="/ex02", method=RequestMethod.GET)
	public String ex02() {
		return "ex02";
	}
	
	@PostMapping("/ex02")	// @GetMapping, @PostMapping 등은 스프링 4.1.0 이상부터 가능
	public String ex02(@ModelAttribute("name") String name, @RequestParam int age, Model model) {
		
		String adult = age >= 20 ? "성인" : "미성년자";
		
//		model.addAttribute("name", name);
		model.addAttribute("age", age);
		model.addAttribute("adult", adult);	// request.setAttribute("adult", adult);
		
		return "ex02Result";
	}
	// @RequestParam : request.getParameter(변수이름) => 생략가능
	// @ModelAttribute : 파라미터 그대로 model에 attribute로 등록하기, 파라미터 이름을 명시해주기
}
----------------
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>ex02 (POST)</h1>
<hr>

<h3>${name }님은 ${age }살이고, ${adult }입니다</h3>

</body>
</html>
===========================================================================
//home.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:set var="cpath">${pageContext.request.contextPath }</c:set>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>day01</title>
</head>
<body>

<h1>컨트롤러 예제</h1>
<hr>

<ul>
	<li><a href="${pageContext.request.contextPath }/ex01">ex01 - 링크를 클릭하면 연결되는 함수</a></li>
	<li><a href="${cpath }/ex02">ex02 - 컨트롤러에 주로 사용하는 어노테이션</a></li>
	<li><a href="${cpath }/ex03">ex03 - 커맨드 객체</a></li>
	<li><a href="${cpath }/ex04">ex04 - Model And View</a></li>
	<li><a href="${cpath }/ex05">ex05 - Path Variable</a></li>
	<li><a href="${cpath }/calc">calc - 두 수의 사칙연산 계산기</a></li>
</ul>

</body>
</html>
-----------------
//ex03.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>ex03 (GET)</h1>
<hr>

<form method="POST">
	<input type="text" name="name" placeholder="이름을 입력하세요" required autofocus>
	<input type="number" name="age" placeholder="나이를 입력하세요" required>
	<input type="submit" value="제출">
</form>

</body>
</html>
---------------------
//Ex03Controller.java
package com.itbank.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;

import com.itbank.member.MemberDTO;

@Controller
public class Ex03Controller {

	@GetMapping("/ex03")
	public void ex03() {}
	// 컨트롤러 메서드의 반환형이 void이면 @RequestMapping의 value가 viewName이 된다
	// => 요청 주소 그대로 jsp를 찾아간다
	
//	@PostMapping("/ex03")
//	public String ex03(MemberDTO dto, Model model) {
//		model.addAttribute("dto", dto);
//		return "ex03Result";
//	}
	
	@PostMapping("/ex03")
	public String ex03(@ModelAttribute("dto") MemberDTO dto) {
		return "ex03Result";
	}
	// ModelAttribute에서 지정하는 이름은 view에서 EL태그로 참조할 이름이다 -> dto. 으로 참조가능
}
-------------
package com.itbank.member;

// 스프링 빈은 싱글톤인데, DTO는 서로 다른 값을 가지는 여러 객체가 존재해야 하므로, 스프링 빈으로 등록하지 않는다

public class MemberDTO {
	
	private String name;
	private int age;
	
	public String getName() {
		return name;
	}
	public void setName(String name) {
		this.name = name;
	}
	public int getAge() {
		return age;
	}
	public void setAge(int age) {
		this.age = age;
	}
}
----------------------
//ex03Result.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>ex03 (POST)</h1>
<hr>

<h3>${dto.name }님은 ${dto.age }살이고, ${dto.age >= 20 ? '성인' : '미성년자' }입니다</h3>

</body>
</html>
====================================================================================
//home.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:set var="cpath">${pageContext.request.contextPath }</c:set>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>day01</title>
</head>
<body>

<h1>컨트롤러 예제</h1>
<hr>

<ul>
	<li><a href="${pageContext.request.contextPath }/ex01">ex01 - 링크를 클릭하면 연결되는 함수</a></li>
	<li><a href="${cpath }/ex02">ex02 - 컨트롤러에 주로 사용하는 어노테이션</a></li>
	<li><a href="${cpath }/ex03">ex03 - 커맨드 객체</a></li>
	<li><a href="${cpath }/ex04">ex04 - Model And View</a></li>
	<li><a href="${cpath }/ex05">ex05 - Path Variable</a></li>
	<li><a href="${cpath }/calc">calc - 두 수의 사칙연산 계산기</a></li>
</ul>

</body>
</html>
--------------------
//Ex04Controller
package com.itbank.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.servlet.ModelAndView;

import com.itbank.member.MemberDTO;

@Controller
public class Ex04Controller {

	@GetMapping("/ex04")
	public void abcd() {}
	// 함수이름은 반환형과 아무 상관이 없다
	
	// 함수의 반환형은 viewName이고, view에게 객체를 전달하기 위해서 Model을 사용한다
	// 둘다 DispatcherServlet을 통해서 전달하므로, 두 요소를 하나로 묶어서 반환하도록 ModelAndView를 사용할 수 있다
	// ModelAndView = Model model + String viewName
	@PostMapping("/ex04")
//	public ModelAndView ex04(ModelAndView mav, MemberDTO dto) {	// ModelAndView는 매개변수로 받을 수도 있다
	public ModelAndView ex04(MemberDTO dto) {
		
//		ModelAndView mav = new ModelAndView("ex04Result"); 	// 바로 생성자 매개변수로 viewName을 전달해도 된다
		
		ModelAndView mav = new ModelAndView();				// 기본 생성자로 객체를 생성하고
		mav.setViewName("ex04Result");						// viewName 을 setter로 지정할 수 있다
		
		mav.addObject("dto", dto);		// (공통부분)view에게 전달할 attribute를 addObject(name, object) 로 전달한다
		
		return mav;
	}
}
-----------------
//ex04.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8" pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>ex04 (GET)</h1>
<hr>

<form method="POST">
	<input type="text" name="name" placeholder="이름을 입력하세요" required autofocus>
	<input type="number" name="age" placeholder="나이를 입력하세요" required>
	<input type="submit" value="제출">
</form>

</body>
</html>
----------------
//ex04Result.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>ex04 (POST)</h1>
<hr>

<h3>${dto.name }님은 ${dto.age }살이고, ${dto.age >= 20 ? '성인' : '미성년자' }입니다</h3>

</body>
</html>

=====================================================================================
//ex05.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>ex05 - 경로 변수</h1>
<hr>

<h3>${msg }</h3>

<form>
	<input name="name">
	<input type="submit" value="전송">
</form>
<script>
	const form = document.forms[0]
	
	form.onsubmit = function(event) {
		event.preventDefault()					// form의 기본작동(submit) 을 막는다
		const name = form.children[0].value		// form 태그 안의 자식 요소 중 첫번째 요소의 value를 가져와서 name에 저장
		alert(name)								// 확인용으로 출력
		const cpath = '${pageContext.request.contextPath}'	// 자바스크립트에서 cpath를 쓰기위해서 저장
		location.href = cpath + '/ex05/' + name	// 지정한 주소로 이동
	}
</script>


</body>
</html>
-----------
package com.itbank.controller;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.servlet.ModelAndView;

@Controller
public class Ex05Controller {

	@GetMapping("/ex05")
	public void ex05() {}
	
	@GetMapping("/ex05/{name}")
	public ModelAndView ex05(@PathVariable String name) {
		ModelAndView mav = new ModelAndView("ex05");
		mav.addObject("msg", "안녕하세요, " + name);
		return mav;
	}
	// @PathVariable : 경로 변수, 요청 주소에 일부분을 파라미터로 취급하여 받을 수 있다
	// GET 요청시 파라미터의 표현방식인 쿼리스트링을 대체할 수 있다
}
=====================================================================================
//calc.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>두 수의 사칙연산 계산기</h1>
<hr>

<form method="POST">
	<input type="number" name="n1" value="${param.n1 }" 
		   style="width: 50px;" placeholder="n1" required autofocus>
	<select name="oper">
		<option ${param.oper == '+' ? 'selected' : ''}>+</option>	
		<option ${param.oper == '-' ? 'selected' : ''}>-</option>	
		<option ${param.oper == '*' ? 'selected' : ''}>*</option>	
		<option ${param.oper == '/' ? 'selected' : ''}>/</option>	
	</select>
	<input type="number" name="n2" value="${param.n2 }"
	       style="width: 50px;" placeholder="n2" required>
	<input type="submit" value="=">
</form>

<c:if test="${not empty dto }">
	<h3>${dto.n1 } ${dto.oper } ${dto.n2 } = ${dto.answer }</h3>
</c:if>
</body>
</html>
------------------
package com.itbank.calc;

public class CalcDTO {
	private int n1, n2, answer;	// 파라미터에 포함되지 않는 필드를 만들어도 상관없다
	private String oper;
	
	public int getN1() {
		return n1;
	}
	public void setN1(int n1) {
		this.n1 = n1;
	}
	public int getN2() {
		return n2;
	}
	public void setN2(int n2) {
		this.n2 = n2;
	}
	public int getAnswer() {
		return answer;
	}
	public void setAnswer(int answer) {
		this.answer = answer;
	}
	public String getOper() {
		return oper;
	}
	public void setOper(String oper) {
		this.oper = oper;
	}
	
	
}
----------
package com.itbank.controller;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;

import com.itbank.calc.CalcDTO;

@Controller
public class CalcController {

	@GetMapping("/calc")
	public String calc() {
		return "calc";	// calc.jsp
	}
	
	@PostMapping("/calc")
	public String calcProcess(CalcDTO dto, Model model) {
		int n1 = dto.getN1();
		int n2 = dto.getN2();
		
		switch(dto.getOper()) {
			case "+":	dto.setAnswer(n1 + n2);	break;
			case "-":	dto.setAnswer(n1 - n2);	break;
			case "*":	dto.setAnswer(n1 * n2);	break;
			case "/":	dto.setAnswer(n1 / n2);	break;
		}
		model.addAttribute("dto", dto);
		
		return "calc";	// calc.jsp
	}
}
================================================================================
//rootContext
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xsi:schemaLocation="http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">
	
	<!-- Root Context: defines shared resources visible to all other web components -->
	<!-- DispatcherServlet이 아니더라도 모든 웹 컴포넌트가 공유할 수 있는 객체를 스프링 빈으로 선언 -->
	
	<bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">
		<property name="driverClass" value="oracle.jdbc.driver.OracleDriver" />
		<property name="jdbcUrl" value="jdbc:oracle:thin:@192.168.1.100:1521:xe" />
		<property name="user" value="c##itbank" />
		<property name="password" value="it" />
		<property name="maxPoolSize" value="100" />
		<property name="maxIdleTime" value="600" />
		<property name="idleConnectionTestPeriod" value="300" />
	</bean>
	
	<!-- JSP에서는 dataSource를 우리가 직접 받아서 사용했지만, 여기서는 jdbcTemplate에게 넘겨준다 -->
	<bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">
		<property name="dataSource" ref="dataSource" />
	</bean>
	
	<context:component-scan base-package="com.itbank.model" />
	<context:component-scan base-package="com.itbank.service" />
	
	
		
</beans>
------------
//home.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:set var="cpath">${pageContext.request.contextPath }</c:set>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>jdbcTemplate 테스트</h1>
<hr>
<h3>${msg }</h3>

<ul>
	<li><a href="${cpath }/join">회원가입 예제</a></li>
	<li><a href="${cpath }/list">회원목록 확인</a></li>
</ul>

</body>
</html>
-----------------
//HomeController
package com.itbank.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

import com.itbank.service.DBTestService;

@Controller
public class HomeController {
	
	@Autowired	// 스프링 빈 중에서 타입이 일치하는 객체를 자동으로 맵핑한다 (의존 주입)
	private DBTestService ds;// = new DBTestService();

	@RequestMapping("/")	// 요청 메서드에 상관없이 주소만으로 판별하려면 RequestMapping으로 처리하면 된다
	public String home(Model model) {

		String msg = ds.getTest();
		model.addAttribute("msg", msg);
		return "home";
	}
}
--------------------
//DBTestService
package com.itbank.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.itbank.model.DBTestDAO;

@Service	// 스프링 빈으로 등록하는 어노테이션
public class DBTestService {
	
	@Autowired private DBTestDAO dao;
	
	public String getTest() {

		return dao.selectVersion();
	}

}
-------------------
//DBTestDAO
package com.itbank.model;

import java.sql.ResultSet;
import java.sql.SQLException;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

@Repository
public class DBTestDAO {
	
	@Autowired private JdbcTemplate jt;

	public String selectVersion() {
		String sql = "select banner from v$version";
//		RowMapper<String> rowMapper = (ResultSet rs, int rowNum) -> {
//			return rs.getString("banner");
//		};	// 람다식을 활용한 함수형 인터페이스 객체 생성
		
		RowMapper<String> rowMapper = new RowMapper<String>() {
			@Override
			public String mapRow(ResultSet rs, int rowNum) throws SQLException {
				return rs.getString("banner"); //위의 sql결과를 rs로 가져온다
			}
		};	// 추상 클래스를 상속받는 익명클래스 객체 생성
		String result = jt.queryForObject(sql, rowMapper);
		return result;
	}

}
==================================================================================
//home.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:set var="cpath">${pageContext.request.contextPath }</c:set>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>jdbcTemplate 테스트</h1>
<hr>
<h3>${msg }</h3>

<ul>
	<li><a href="${cpath }/join">회원가입 예제</a></li>  //클릭시 controller -> step1.jsp
	<li><a href="${cpath }/list">회원목록 확인</a></li>
</ul>

</body>
</html>
-------------------
//MemberController
package com.itbank.controller;

import java.io.IOException;
import java.util.List;

import javax.servlet.http.HttpServletRequest;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestHeader;
import org.springframework.web.servlet.ModelAndView;

import com.itbank.model.MemberDTO;
import com.itbank.service.MemberService;

@Controller
public class MemberController {
	
	@Autowired private MemberService ms;
	
	@GetMapping("/join")
	public ModelAndView join(HttpServletRequest request) throws IOException {
		ModelAndView mav = new ModelAndView("join/step1");
		
		String path = request.getSession().getServletContext().getRealPath("resources/agreement.txt");
		System.out.println(path);
		
		String agreement = ms.getAgreement(path);
		mav.addObject("agreement", agreement);
		
		return mav;
	}
	
	@GetMapping("/join/step2")
	public ModelAndView join2(String agree, @RequestHeader("referer") String referer) {
		// @RequestHeader(name) = request.getHeader(name) 
		
		ModelAndView mav = new ModelAndView("join/step2");
		
		System.out.println("동의 : " + agree);
		System.out.println("referer : " + referer);
		
		if(agree == null) {
			mav.setViewName("alert");
			mav.addObject("msg", "약관에 동의하셔야 가입이 가능합니다");
			mav.addObject("url", referer);
		}
		return mav;
	}
	
	@PostMapping("/join/step3")
	public ModelAndView join3(MemberDTO dto) {
		System.out.println(dto);
		int row = ms.insert(dto);
		ModelAndView mav = new ModelAndView();
		
		if(row == 1) {
			mav.setViewName("redirect:/"); 	// viewName 의 시작이 redirect: 이면 리다이렉트로 처리함
			// 리다이렉트는 jsp를 가리키지 않고, 요청 주소를 가리킨다 -> @RequestMapping 과 매칭되어야 한다
		}
		else {
			mav.setViewName("alert");
			mav.addObject("msg", "회원 가입 실패 !!");
		}
		return mav;
	}
	
	@GetMapping("/list")
	public ModelAndView list() {
		ModelAndView mav = new ModelAndView();
		
		List<MemberDTO> list = ms.getMemberList();
		mav.addObject("abcd", list);
		
		return mav;
	}
}
--------------------
#)join/step1.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:set var="cpath">${pageContext.request.contextPath }</c:set>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>step1 : 회원 가입 약관 동의</h1>
<hr>

<form action="${cpath }/join/step2">
	<textarea style="width: 800px; height: 400px; resize: none;" readonly>${agreement }</textarea>
	<p>
		<label>
			<input type="checkbox" name="agree">위 사항을 읽었으며, 약관에 동의합니다  //agree로 체크했는지 확인
		</label>
	</p>
	<input type="submit" value="다음">
</form>

</body>
</html>
-----------------------
#)join/step2.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<c:set var="cpath">${pageContext.request.contextPath }</c:set>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>step2 : 회원 가입 정보 입력</h1>
<hr>
<form method="POST" action="${cpath }/join/step3">
	<p><input type="text" name="userid" placeholder="ID" required autofocus></p>
	<p><input type="password" name="userpw" placeholder="Password" required></p>
	<p><input type="text" name="username" placeholder="Your Name" required></p>
	<p><input type="email" name="email" placeholder="foo@bar.com" required></p>
	<p>
		<label><input type="radio" name="gender" value="남성" required>남성</label>
		<label><input type="radio" name="gender" value="여성" required>여성</label>
	</p>
	<p><input type="submit" value="가입"></p>
</form>

</body>
</html>
---------------------
//MemberDTO
package com.itbank.model;

public class MemberDTO {
	
	private String userid;
	private String userpw;
	private String username;
	private String email;
	private String gender;
	
	@Override
	public String toString() {
		return String.format("{%s, %s, %s, %s, %s}", userid, userpw, username, email, gender);
	}
	
	public String getUserid() {
		return userid;
	}
	public void setUserid(String userid) {
		this.userid = userid;
	}
	public String getUserpw() {
		return userpw;
	}
	public void setUserpw(String userpw) {
		this.userpw = userpw;
	}
	public String getUsername() {
		return username;
	}
	public void setUsername(String username) {
		this.username = username;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public String getGender() {
		return gender;
	}
	public void setGender(String gender) {
		this.gender = gender;
	}
}
--------------
//memberservice
package com.itbank.service;

import java.io.File;
import java.io.IOException;
import java.util.List;
import java.util.Scanner;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.itbank.model.MemberDAO;
import com.itbank.model.MemberDTO;

@Service
public class MemberService {

	@Autowired private MemberDAO dao;
	
	public String getAgreement(String path) throws IOException {
		String agreement = "";
		File f = new File(path);
		
		if(f.exists() == false) {
			System.out.println("파일이 없습니다 !!");
			return null;
		}
		Scanner sc = new Scanner(f);
		while(sc.hasNextLine()) {
			agreement += sc.nextLine() + "\n";
		}
		sc.close();
		return agreement;
	}

	public int insert(MemberDTO dto) {
		// 나중에 비밀번호 값을 해시처리하는 코드 추가 예정
		return dao.insert(dto);
	}

	public List<MemberDTO> getMemberList() {
		return dao.selectList();
	}
}
------------
//memberdao
package com.itbank.model;

import java.sql.ResultSet;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.jdbc.core.RowMapper;
import org.springframework.stereotype.Repository;

@Repository
public class MemberDAO {

	@Autowired private JdbcTemplate jt;

	public int insert(MemberDTO dto) {
		String sql = "insert into member values (?, ?, ?, ?, ?)";
		return jt.update(sql, dto.getUserid(), dto.getUserpw(), dto.getUsername(), dto.getEmail(), dto.getGender());
	}
	

	public List<MemberDTO> selectList() {
		// SQL을 실행하기 위한 쿼리문
		String sql = "select * from member order by userid";
		
		// 결과를 받아서 어떻게 DTO에 맵핑할 것인가 결정하는 함수를 객체 형태로 생성
		RowMapper<MemberDTO> mapper = (ResultSet rs, int rownum) -> {
			// JSP DAO에서 while문 내부에 작성하던 코드를 그대로 작성
			MemberDTO dto = new MemberDTO();
			dto.setUserid(rs.getString("userid"));
			dto.setUserpw(rs.getString("userpw"));
			dto.setUsername(rs.getString("username"));
			dto.setEmail(rs.getString("email"));
			dto.setGender(rs.getString("gender"));
			return dto;
		};
		
		// sql문과 mapper 함수객체를 전달하면 jdbcTemplate 이 쿼리문을 수행하고 알아서 결과를 반환함
		// 이때, jt.query()는 List<T> 를 반환하고, jt.queryForObject() 는 T 를 반환한다
		List<MemberDTO> list = jt.query(sql, mapper);
		
		// 받아온 list를 반환
		return list;
	}
}
---------------------
//list.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<h1>회원 목록 출력</h1>
<hr>

<table border="1" cellpadding="7" cellspacing="0">
	<tr>
		<th>userid</th>
		<th>userpw</th>
		<th>username</th>
		<th>email</th>
		<th>gender</th>
	</tr>
<c:forEach var="dto" items="${abcd }">
	<tr>
		<td>${dto.userid }</td>
		<td>${dto.userpw }</td>
		<td>${dto.username }</td>
		<td>${dto.email }</td>
		<td>${dto.gender }</td>
	</tr>
</c:forEach>
</table>


</body>
</html>
================================================================================
//alert.jsp
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>

<script>
	alert('${msg}')
	location.href = '${url}'
</script>

</body>
</html>
==============================================================================
package myServlet;

import java.io.IOException;
import java.io.PrintWriter;

import javax.servlet.RequestDispatcher;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

//서블릿은 웹의 요청과 응답을 처리 할 수 있는 자바 클래스이다.
//JSP 이전에 서블릿 기술이 먼저 등장했다
//JSP도 실행 될 때는 서블릿의 형태로 바뀌고 나서 실행된다
//서블릿을 만들 때에는 HttpServlet 클래스를 상속받는다. 그렇기 때문에 기능을 하나하나 구현할 필요없다

//상단에 sourcel -> Overrid implement -> 상속받은 것들을 쓴다

//이걸 실행시키면 http://localhost:8080/Day21/ex01 이렇게 뜬다.


//이 서블릿은 web.xml에 등록이 되있고 매핑이 되있어서 프로젝트 전체에서 인식이 된다.
//그렇게 때문에 경로에 문서의 경로를 노출 시키지 않을 수 있다.
//ex01이 파일일 필요가없다. -> 그냥 매핑만 시켜주면된다 -> xml로 구성
//그래서 이 자바소스를 실행시켜도 웹에서도 볼수 있다.

//오버라이딩해보자
public class Servlet01 extends HttpServlet {
	
	//서블릿은 요청을 받아야 실행이된다.
	@Override
	protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		request.setCharacterEncoding("UTF-8");
		response.setCharacterEncoding("UTF-8");
		PrintWriter out = response.getWriter(); //응답에 글자를 찍어주는 객체 -> out
		//이 부분은 forward로 인해서 안보임
		out.print("<h1>Myservlet01</h1>");
		out.print("<hr>");
		out.print("<h3>Hello, world !!</h3>");
		
		out.print("<marquee direction=\"up\">Hi</marquee>");
		// <text area style=\"resize: none;\"> 이렇게 쓰는게 불편해서 jsp가 등장한것이다
		
		//요청에 대한 처리는 자바코드에서 하고, 응답은 자바에서 위에서처럼 html쓰기 불편하니까 jsp로 넘기자
		//주소를 그대로 두고, 화면만 바꾸려면? -> 포워드
		
		//포워드 하기전에 넘길 객체를 request에 넣어두면 -> jsp에서 객체 띄울수있다.
		//즉, 객체생성같은 처리는 java에서 출력(뷰)는 jsp에서

		request.setAttribute("msg", "지금부터 쉬는 시간입니다");
		
		//이렇게 되면서 ex01.jsp는 단독으로 사용안되면서(WEB-INF에 넣었기때문) 포워드로 접근가능하다
		RequestDispatcher rd = request.getRequestDispatcher("/WEB-INF/views/ex01.jsp");
		rd.forward(request, response);
		//이 코드를 실행시키면 http://localhost:8080/Day21/ex01 로 갔는데
		//ex01.jsp를 보여준다 주소창에는 매핑이된 ex01로 띄어줌
	}
	
}

-----------
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
	<!-- jsp의 단독실행(msg에 아무것도안뜸)을 막기 위해 web-inf에 넣는다. -->
	<h1>ex01.jsp</h1>
	<h3>이 파일은 서블릿에 의해서 포워딩 이후 보여지는 파일입니다.</h3>
	<h3>msg: ${msg }</h3>
</body>
</html>
=======================================================================
#)스프링 설치
1. java -version으로 1.8버전인지 확인
2. eclipse 2019-06버전으로 통일
3. workspace-spring 폴더 생성
4. eclipse 실행 -> workspace-spring으로 launch 경로지정
5. window -> preferences -> 웹브라우저 -> 크롬 , 
   workspace -> utf-8 , 
   server -> runtimeenvir -> add -> apache 8.5 -> %CATALINA_HOME% 으로 검색 후 추가
   web -> css files,html, jsp -> utf-8, 
6. help -> eclipse market place -> find: sts (spring tools suite의 약어)  -> 젤위에거 -> confirm -> 약관동의 후 설치
7. 밑에 servers에 서버 추가
8. 프로젝트생성 (new -> project -> 스크롤내리면 spring이라는 폴더 -> next -> project이름지정(test, top-level-package와 동일하게 해주자) , 가장아래쪽에있는 spring MVC project클릭 -> next -> top-level package를 com.itbank.test이름으로 설정 ->finish
   -> test 프로젝트 구조를 보면 Spring Elements 가 있는지 확인
9. spring legacy project에는 
1)pom.xml
 - 스프링 프로젝트는 메이븐 기반 프로젝트이다
 - 메이븐은 외부 라이브러리를 관리한다(인터넷에 있는 url만 지정하면 자동으로 .m2에 다운받고 여기있는 파일들을 내 프로젝트에 포함시켜준다) -> pom.xml 기존에는 우리가 lib를 다운받아서 끌어와 썻다
 - pom.xml은 메이븐 프로젝트에 포함시킬 라이브러리를 관리한다.
    pom.xml에서 아래 버전으로 수정
	<properties>
		<java-version>1.8</java-version>
		<org.springframework-version>4.3.30.RELEASE</org.springframework-version>
		<org.aspectj-version>1.6.10</org.aspectj-version>
		<org.slf4j-version>1.6.6</org.slf4j-version>
	</properties>
	
	<plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>2.5.1</version>
                <configuration>
                    <source>1.8</source>
                    <target>1.8</target>
                    <compilerArgument>-Xlint:all</compilerArgument>
                    <showWarnings>true</showWarnings>
                    <showDeprecation>true</showDeprecation>
                </configuration>
    </plugin>
	
	alt + f5 로 프로젝트 새로고침하면 알아서 버전이 바뀐다
 
2)web.xml
 - 웹 프로그램으로 가져야할 기본 사항을 설정
 - 스프링에 의해서 모든 요청을 처리하는 DispatcherServlet을 선언 -> 프로젝트에 Deployment descriptor: test 더블클릭하면 web.xml이 보인다
 - 인코딩 필터, 서블릿 상세 설정 파일 경로 포함
 
- web-app version: 3.1로 수정하기 (Deployment Descriptor를 더블클릭)
- schemaLoaction: 3_1로 수정

<web-app version="3.1" xmlns="http://java.sun.com/xml/ns/javaee"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://java.sun.com/xml/ns/javaee https://java.sun.com/xml/ns/javaee/web-app_3_1.xsd">

3)root.context.xml
 - 요청과 응답에 상관없이 프로젝트가 참조해야할 객체를 선언
4)servlet-context.xml
 - 주로 요청과 응답에 관여하는 객체를 선언
 
순서 -> pom.xml이 실행 libraries 밑에 maven에 수많은 jar이 있다. -> web.xml에서는 displatcher servlet이라는 class를 이용해서 name이 appServlet 작동(모든요청에 대해서)
 -> javaresources -> src/main/java -> com.itbank.test 에 HomeController.java작성 -> Spring Elements -> Beans -> Servlet-context.xml 확인
 -> Deployed Resources -> webapp -WEB-INF -views - home.jsp작성 (test프로젝트 우클릭으로 실행)


view와 controller를 분리하는 이유 -> 유지보수 때문에 (front단은 view)

#)home.jsp는 새로 만드는게 좋다. 기존에 있는거 지우고

#)pom.xml에서 
java-version 이라는 변수가 있고 그게 1.8이다
<java-version>1.8</java-version>

#)브라우저에 요청을 날리면 displatcher가 처음 받게 되고 (web.xml설정에의해서) 객체를 찾고 (어노테이션으로찾는닫)
-> http://localhost:8080/test2/ 이렇게 '/' 최상위 요청이 왓으니 @RequestMapping("/")를 실행된다
-> return "home"인데 이거는 포워드로 넘어간다. 그렇게 되면서 home.jsp에는 참조할 수 있게 된다.


---------------------------------
#)메이븐을 만들어보자

#)new project -> Maven project -> create a simple project 체크 -> 
group id : com.itbank
artifact : test3 (프로젝트이름의 역할, 다른 프로젝트와 구분할 수 있는 id역할)
packaging: jar


//Ioc (inversion of Control) : 제어 역전
-> 일반적으로 프로그래밍을 작성할 떄 프로그램이 흘러가는 흐름이나 생성되는 객체에 대한 제어권을 만드는 개발자가 가지는 것과 달리
   프레임 워크가 가지는 것을 의미한다.
-> 개발자가 코드의 흐름이나 객체 생성에 관련된 코드를 프로그래밍 코드에 직접 작성하는 것이 아닌 프레임워크가 사용하는 파일에
   작성하면 이를 토대로 프레임워크가 객체를 생성하여 반환하고 코드가 동작하는 순서를 결정하게 된다는 의미이다.
-> 즉, 처음부터 프로그램 종료될때까지 코드의 흐름을 원래 개발자가 만들었는데 IOC를 적용한 개발방식은 개발자가 몇가지 세팅만 해주면
   세팅된 정보를 토대로 해서 프로그램이 흘러가는 부분은 프레임워크가 해준다.

Ioc는 POJO Class를 핵심적으로 사용한다 POJO Class는 java bean이다.
-> 자바 모델이나, 기능, 프레임워크 등에 따르지 않고 홀로 독립적이며 단순한 기능만을 가진 객체들을 의미

IoC 컨테이너의 종류 : BeanFactory, ApplicationContext

#)BeanFactory
객체 생성 주소값 반환, 상속 등 객체간의 관계를 형성 관리
Bean에 관련된 설정을 위한 xml파일은 즉시 로딩하지만 객체는 개발자가 요구 할 때 생성한다

#)ApplicationContext
객체 생성 주소값 반환, 상속 등 객체간의 관계를 형성 관리
Bean에 관련된 설정을 위한 xml파일은 즉시 로딩하면서 객체를 미리 생성해서 가지고 있다.
ClassPathXmlApplicationContext
FileSystemXmlApplicationContext
XmlWebApplicationContext

------------------
#)수업
- 스프링프레임워크에서는 객체를 미리 등록하여 불러와서 사용한다(부를 때마다 생성하면 메모리 과부하 문제다)
- 객체 용도별로 연관성 있는 객체가 모여있다(참조, 의존성), 중식,양식 관련조리도구가있고 색깔별로 있다(육류 등)
- 스프링에서 사용하기 위해소는 객체를 미리 등록해야한다
여기 등록하는 방법은

1) <bean id="객체이름" class="패키지.클래스" />

2) <bean id="객체이름" class="패키지.클래스">
       <property name="age" value="29" />
       <property name="score">100</property>
   </bean>

3) <bean id="객체이름" class="패키지.클래스">
       <property name="member" ref="m1" />
   </bean>

4) <bean id="객체이름" class="패키지.클래스">
       <constructor-arg value="이지은" />
       <constructor-arg value="29" />
   </bean>


1)번은 클래스 객체이름 = new 클래스(); 와 같다
2)번은 클래스 객체이름 = new 클래스();
	객체이름.setAge(29);
3)번은 클래스 객체이름 = new 클래스();
  객체이름.setMember(m1); //참조변수 값
4)번은 클래스 객체이름 = new 클래스("이지은", 29);

// 지정한 패키지 내에 클래스 중에서 특정 어노테이션이 붙은 클래스를
// 객체로 생성하고 스프링 빈으로 등록해라
// 특정 어노테이션의 종류

@Controller에는 함수를 적을때	Web관련된	: MVC에서 컨트롤러, 서블릿에게 요청을 넘겨받음
@Service (java, 단독으로도 실행가능한 코드, web,db가 하기 애매한거를 service에 넣는다) : 컨트롤러가 호출할 수 있는 함수를 모아서 가지는 객체, Model이나 Controller에 종속적이지 않은 코드를 작성
@Repository(DB, select,update등)		: 데이터의 저장소, 즉 DB에 접근하는 객체, 보통 DAO를 가리킨다
@Component		: 용도는 명확하지 않으나, 스프링 빈으로 등록하여 사용할 객체
@RestController		: 기존 컨트롤러의 기능에서 모든 메서드에 @ResponseBody가 자동으로 적용된다. AJAX용으로 사용
@ControllerAdvice 	: 지정한 범위에서 발생하는 모든 예외를 집중시켜 처리하는 클래스

매개변수 가능한 자료형
HttpServletRequest
HttpSession
String
DTO
Model
ModelAndView

반환형 가능한 자료형
void
String
ModelAndView

=======================================================================
#)요청은 스프링서버에들어와서 디스패처가 감지하고 스프링빈중에서 컨트롤러중에서 어떤객체를 쓸거냐(그중에 메서드) 찾는다.

#)javaresources > src/main/java > com.itbank.controller로 바꾸고 홈페이지 띄우면 주소가 여전히 (servlet-context보면 바껴있다)
localhost:8080/day01이다. 

#)netstat -ano | findstr 8080
#)taskkill /f /pid 8136 

========================================================================
#)root-context수정
#)pom.xml에 넣기
#)spring jdbc(4.3.30 스프링버전이랑 맞춰야된다) , c3p0(커넥션풀을 대신해주는), ojdbc8 메이븐프로젝트 검색

<!-- xml의 서버상 경로에 한글이 포함되어도 예외를 발생시키지 않게 처리해주는 라이브러리 (내 컴퓨터안의 경로가 한글이어도)-->
		<dependency>
		    <groupId>xerces</groupId>
		    <artifactId>xercesImpl</artifactId>
		    <version>2.12.1</version>
		</dependency>
		
		<!-- https://mvnrepository.com/artifact/org.springframework/spring-jdbc -->
		<!-- 스프링에서 DB접속  기능을 지원해주는 라이브러리 -->
		<dependency>
		    <groupId>org.springframework</groupId>
		    <artifactId>spring-jdbc</artifactId>
		    <version>${org.springframework-version}</version>
		</dependency>
		        
		        
		<!-- https://mvnrepository.com/artifact/com.mchange/c3p0 -->
		<!-- 스프링에서 사용할 수 있는 가장 기초적인 커넥션 풀 -->
		<dependency>
		    <groupId>com.mchange</groupId>
		    <artifactId>c3p0</artifactId>
		    <version>0.9.5.5</version>
		</dependency>
		
		<!-- https://mvnrepository.com/artifact/com.oracle.database.jdbc/ojdbc8 -->
		<!-- 오라클 데이터베이스에 접근하기 위한 드라이버 라이브러리 -->
		<dependency>
		    <groupId>com.oracle.database.jdbc</groupId>
		    <artifactId>ojdbc8</artifactId>
		    <version>21.3.0.0</version>
		</dependency>
=======================================================================================================
#)간단 정리
1)클래스를 작성할 패키지를 root-context.xml혹은 servlet-context.xml에 base-package로 등록한다.
(스프링 빈을 설정하기 위한 밑작업)
2) 내가 직접 작성하는 클래스가 아니라면, <bean>태그를 이용하여 클래스르르 불러와서 빈으로 등록한다
3)클래스를 작성한다. 이때 클래스는 @Controller, @Service, @Repository 와 같은 어노테이션에 의해 스프링 빈으로 등록된다.
(스프링이 객체를 컨테이너 내부에 싱글톤 형식으로 생성하고, 필요하다면 객체간의 의존성을 스프링이 연결(주입)한다)
4)요청 -> 컨트롤러 @RequestMapping -> @Service의 함수 -> @Repository
반환값이 역순으로 반환되고, 보통 반환값을 model.addAttribute(name,value)
                            mav.addObject(name, value) 형식으로 처리한다
5)컨트롤러의 @RequestMapping 함수는 String 혹은 ModelAndView를 반환하면서 ViewName을 DispatcherServlet에게 전달
6) DispatcherServlet은 prefix + viewName + suffix를 만들어서 포워딩한다
단, viewName.startWith("redirect:")이면 포워드를 수행하지않고, 지정한 주소로 리다이렉트한다
7) 포워드라면,jsp의 내용이 화면이 출력되고, 리다이렉트라면, 다시 @RequestMapping의 함수를 호출한다.

@Service는 순수 자바코드로 처리가능한 곳
@Service
public class xxService {
	public List<xx> getList() {
		return dao.selectList();
	}
}

---------------------------------------------------------------------
#)myBatis란 영속성(Persistent) 프레임워크이다.
-> 프로그램이 종료되어도 데이터가 유실되지 않는다.
-> 데이터베이스에 저장해두면 웹서버를 꺼도 데이터는 살아있다

#)ORM
O: object    객체 (Object Oriented Programming)
R: Relation  관계 (Relation DBMS)
M: Mapping   매핑 (위에것을 자동으로 매핑해준다 dto, row들을 맞춰주기 위해서 우리가 rs.set이렇게했는데, mybatis는 ORM을 지원
하기 때문에 쿼리문만 쓰면된다)

=======================================
#)mybatis xml으로 구현
rootcontext.xml로딩이 끝나면
sqlSessionTemplate을 준비한다 -> mybatis-config.xml, sqlmap-***.xml파일이 불러온다
설정에의해서***Service,***DA0(sqlmap-***.xml)를 불러온다

controller -> service -> dao -> sqlsessiontemplate (statement에 의해) -> sqlmap-**.xml을 참조

sqlmap-1.xml, sqlmap-2.xml 같은 구분하는게 statement이다.

그럼 기존에 dao에서 바로 접근하는게 좋지않나?
간단한 쿼리는 그냥 기존방식 써도된다.
if문을 통해 sql문을 뗏다 붙였다 할 때는 xml을 쓰는게 좋다(쿼리문에 조건문이 가능) -> 동적쿼리

1)mybatis형식을 사용하기 위한 준비한다
root-context.xml에서
 - configLocation: mybatis-config.xml 이 등록되어 있고, 파일이 제자리에 있는지 확인
 - mapperLocations: sqlmap-***.xml 이 등록되어 있고, namespace가 DAO와 연결되어있는지 확인
 
2) 연결이 모두 완료되었다면 Controller -> Service -> DAO -> mapper.xml 로 연결됨
- mapper.xml 을 작성하는 요령
-> namespace는 DAO의 이름을 작성한다
-> <select> <insert> <update> <delete>태그를 사용한다
-> <select> 는 resultType을 명시해야한다.
-> <insert> <update> <delete> 는 resultType이 int로 고정이기 때문에 생략한다
-> 매개변수를 전달한다면 parameterType을 명시한다
-> parameterType은 패키지이름.클래스이름을 모두 작성해야한다


-> 자주 사용하는 클래스 자료형이 있다면, 마이바티스 설정파일에서 typeAliase를 설정하여 줄일 수 있다.
mybatis-config.xml에서
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC
	 "-//mybatis.org/DTD Config 3.0//EN" 
	 "http://mybatis.org/dtd/mybatis-3-config.dtd">
	 
	 <configuration>
	 	<settings>
	 		<setting name="cacheEnabled" value="false"/> <!-- 캐시 사용안한다 -->
	 		<setting name="useGeneratedKeys" value="false"/> <!--  자동으로 만들어지는 키 사용안한다 -->
	 		<setting name="mapUnderscoreToCamelCase" value="false"/>
	 		<!-- 
	 			user_name => (언더바를 대문자로)userName으로 mybatis가 바꾸도록 하겠느냐? 아니다(db랑 맞추기 위해서) 
	 		 -->
	 	</settings>
	 	<typeAliases>
	 		<typeAlias type="com.itbank.member.MemberDTO" alias="member"/>
	 	</typeAliases>
	 </configuration>
========================================================================
pom.xml 에서 artifactId를 바꾸면 context-path도 자동으로 바뀐다. 그러면 /day05 가 프로젝트 최상위이다


//sqlSessionFactory라는게 @Select할 때 부르는건데 그때 sqlmap파일이 없으면 가용할 수없다고 에러가 난다.
<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<!-- <property name="configLocation" value="classpath:config/mybatis-config.xml"/>
		<property name="mapperLocations">
			<list>
				<value>classpath:config/sqlmap-member.xml</value> 두 파일이 만들어져있어야한다
				<value>classpath:config/sqlmap-test.xml</value>
				<value>classpath:config/sqlmap-login.xml</value>
			</list>
		</property> -->
	</bean> 

즉, root-context에 없는 파일이 있으면 안된다

=======================================================================================
day08) css 파일분리시 resources 밑에 폴더만들어서 넣고, servlet-context에 
servlet 수정 (로그인)
=======================================================================================
#)java.util.Date를 java.sql.Date로 바꾸는 방법
public class MainClass { 
  public static void main(String[] args) {
    java.util.Date utilDate = new java.util.Date();
    java.sql.Date sqlDate = new java.sql.Date(utilDate.getTime());
    System.out.println("utilDate:" + utilDate);
    System.out.println("sqlDate:" + sqlDate);
  }
}
=============================================================================
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" import="java.util.Date, java.text.SimpleDateFormat" %>
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Insert title here</title>
</head>
<body>
<%
	Date date = new Date();
	SimpleDateFormat sdf = new SimpleDateFormat("yyyy년 MM월 dd일 hh시 mm분 ss초");
	String today = sdf.format(date);
%>
<h1>지금은 <%=today %>입니다</h1>
==================================================================================
package day04_book;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

// - 도서 이름, 저자, 출판일자, 출판사, 가격, 소개

public class BookDTO {
	private String name, author, publisher, comment;
	private Date publishDate;
	private int price;
	
	// 더미 데이터 생성 및 등록 시 사용할 객체 생성자
	public BookDTO(String name, String author, String publisher, String comment, String publishDate, int price) {
		this.name = name;
		this.author = author;
		this.publisher = publisher;
		this.comment = comment;
		
		Date date = null;
		try {
			date = new SimpleDateFormat("yyyy-MM-dd").parse(publishDate); //sql로 변경(parse)
		} catch (ParseException e) {}
		
		this.publishDate = date;
		this.price = price;
	}
	
	// 기본 생성자
	public BookDTO() {}
==========================================================================================
day09 -> 회원정보수정, interceptor추가

요청을 만들어내는 종류
1)<a>
2)location.href
3)<form><input type="submit">
  <form><button>이것도제출</button></form>
  <form><input type="button" values="이거는 제출아님"></form>
4)XMLHttpRequest (javascript, XHR)
  AJAX(Asynchronous Javascript, And XML => xml을 이용한 요청 및 응답방식, 요즘은 xml대신 json형식을 더많이 사용한다)
  (페이지 변경없이 실시간으로 db에서 데이터를 받아온다)


#)문자열은 equals로 비교
String word1 ="apple";
String word2 ="apple";   -> word1 == word2 는 true이다. 같은 주소를 쓰고있다(재사용, 이미apple이라는 상수가 있으니 새로만들지 말라).
String word4 = sc.nextLine();  -> apple이라고 입력해도 word1,word2와 word4는 다르다. 공간을 미리 만들고 apple저장하니까
String word3 = new String("apple"); ->이것도 마찬가지다. 다르다.(새로운 공간을 만든다) 

//root-context(controller끼리 bean들을 참조할때)를 먼저 읽고 servlet-context를 읽는다.


===========================================================================
#)servlet
<?xml version="1.0" encoding="UTF-8"?>
<beans:beans xmlns="http://www.springframework.org/schema/mvc"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:beans="http://www.springframework.org/schema/beans"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mybatis-spring="http://mybatis.org/schema/mybatis-spring"
	xsi:schemaLocation="http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd
		http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd">

	<!-- DispatcherServlet Context: defines this servlet's request-processing infrastructure -->
	
	<!-- Enables the Spring MVC @Controller programming model -->
	<annotation-driven />

	<!-- Handles HTTP GET requests for /resources/별별 by efficiently serving up static resources in the ${webappRoot}/resources directory -->
	<resources mapping="/resources/**" location="/resources/" />
	<resources mapping="/upload/**" location="file:C:/upload/"/>

	<!-- Resolves views selected for rendering by @Controllers to .jsp resources in the /WEB-INF/views directory -->
	<beans:bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
		<beans:property name="prefix" value="/WEB-INF/views/" />
		<beans:property name="suffix" value=".jsp" />
	</beans:bean>
	
	<beans:bean id="multipartResolver"
		 class="org.springframework.web.multipart.commons.CommonsMultipartResolver">
		 <!-- 최대 업로드 용량 -->
		<beans:property name="maxUploadSize" value="10485760"/>
		
		<!-- 메모리 상에 존재할 수 있는 최대 크기 -->
		<beans:property name="maxInMemorySize" value="10485760"/>
		<!-- 파일이름(혹은 텍스트라면 내용)에 대한 인코딩 -->
		<beans:property name="defaultEncoding" value="utf-8"/>
		
	</beans:bean>
	
	<interceptors> 
		<interceptor>
			
			<mapping path="/**"/>
				<exclude-mapping path="/"/>
				<exclude-mapping path="/login"/>
				<exclude-mapping path="/resources/**"/>
				<exclude-mapping path="/upload/**"/><!-- home에 접근하면 사진뜰수있게 -->
			
			<beans:bean id="loginIntercepter" class="com.itbank.intercepter.LoginIntercepter"/>
			
		</interceptor>
	</interceptors>
	
	<context:component-scan base-package="com.itbank.controller" />
	
	
	
</beans:beans>

-----------------
#)rootcontext
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xmlns:context="http://www.springframework.org/schema/context"
	xmlns:mybatis-spring="http://mybatis.org/schema/mybatis-spring"
	xsi:schemaLocation="http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring-1.2.xsd
		http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd
		http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.3.xsd">
	
	<!-- Root Context: defines shared resources visible to all other web components -->
	<bean id="hikariConfig" class="com.zaxxer.hikari.HikariConfig">
		<property name="driverClassName" value="oracle.jdbc.driver.OracleDriver"/>
		<property name="jdbcUrl" value="jdbc:oracle:thin:@221.164.9.200:50000:xe"/>
		<property name="username" value="c##mango"/>
		<property name="password" value="it"/>
	</bean>
	
	<!-- 기존은 c3p를 썼었다 -->
	<bean id="dataSource" class="com.zaxxer.hikari.HikariDataSource" destroy-method="close">
		<constructor-arg ref="hikariConfig"/>
	</bean>	
	
	<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
		<property name="dataSource" ref="dataSource" />
		<!-- mybatis-config는 들고오자 먼저 -->
		<property name="configLocation" value="classpath:config/mybatis-config.xml"/>
		<property name="mapperLocations">
			<list>
				<value>classpath:config/sqlmap-member.xml</value>
				<value>classpath:config/sqlmap-image.xml</value>
			</list>
		</property>
	</bean>
	
	<bean id="sqlSessionTemplate" class="org.mybatis.spring.SqlSessionTemplate" destroy-method="close">
		<constructor-arg ref="sqlSessionFactory" />
	</bean>
	
	<context:component-scan base-package="com.itbank.service"/>
	<context:component-scan base-package="com.itbank.model"/>
	
	<!-- mybatis-spring은 인터페이스를 스캔 -->
	<mybatis-spring:scan base-package="com.itbank.model"/>
</beans>
==============================================================================
//노트북 -> 전원옵션 -> 절전모드로 변환 -> 해당없음으로해야한다. 좀비프로세스가 될수도있다


front     backend      Database 
get                    select
post                   insert
put                    update(덮어씌운다)  -> pk필요
delete                 delete
patch                  update
options   cors


==================================================================================
@Select("select * from membertest where username like '%'||#{username}||'%' order by username")

http는 요청을 보내면 응답을하고 접속을 끊어버리는 형태이다. 그래서 session이 만들어진것이다.(http는 연결지향형이 아니라서)
-> 웹소켓이 해결(통신터널을 열어놓는다)

===================================================================================
pom, web.xml, root,servletcontext, taglib, cpath

========================================================================================
// @Requestbody 와 @RequestParam 차이

컨트롤러에서 데이터를 인자에 할당하는 대표적인 방법으로는 @RequestBody 와 @RequestParam 이 있다.

form
<input type="text" name="name"~~>
<input type="number" name="age"~~>
form이용해서
이름 :    (name)
나이 : 	 (age)
입력받을때

//RequestParm사용시
@Controller
public class UserController {

	@PostMapping("/receive")
	public String age(@RequestParam String name) {
		System.out.println("통신 성공");
		System.out.println(">>> " + name);
		return "index";
	}
}
//출력 결과
//통신 성공
//>>> jun
@RequestBody 로 데이터를 받을 때는 메서드의 변수명이 상관이 없었지만, @RequestParam 으로 데이터를 받을때는 데이터를 저장하는 이름으로 메서드의 변수명을 설정해주어야 한다.
결과적으로 jun 이라는 이름이 잘 전달이 되었고, 이번엔 name 이라는 변수에 할당이 되어 사용하기에도 용이하다.

-------------------------------
//RequestBody사용시
@Controller
public class UserController {

	@PostMapping("/receive")
	public String age(@RequestBody String name) {
		System.out.println("통신 성공");
		System.out.println(">>> " + name);
		return "index";
	}
}
//출력 결과
//통신 성공
//>>> name=jun&age=13
우리가 입력한 'jun' 이라는 이름과 '13' 이라는 나이가 잘 전달이 되었지만 단지 'name=jun&age=13' 이라는 String 으로 전달되어 전달된 데이터를 사용하기에는 불편함이 있다.
---------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<button id="postData">
    데이터 전송
</button>
<script>
    const $postDataButton = document.querySelector("#postData")

    const postData = event => {
        console.log("데이터 전송");

        fetch("/receive", {
            method: 'post',
            headers: {
                'content-type': 'application/json'
            },
            body : JSON.stringify({
                name : "jun",
                age : "13"
            })
        })
    }

    $postDataButton.addEventListener("click", postData);
</script>
</body>
</html>

'데이터 전송' 버튼을 누르면 
'/receive' 주소로,
post 방식으로,
{name : "jun",
age : "13}
이라는 데이터가 Json의 형태로 전송이 된다.
이 데이터를 @RequestParam 을 이용하여 받아보자.

@Controller
public class UserController {

	@PostMapping("/receive")
	public String age(@RequestParam String name) {
		System.out.println("통신 성공");
		System.out.println(">>> " + name);
		return "result";
	}
}
위와 같이 컨트롤러를 구현한 후 데이터를 전송해보았지만 에러가 발생하였다.

 

MissingServletRequestParameterException: Required String parameter 'name' is not present

 

name 이라는 파라미터가 없다고 한다.

그 이유는 기본적으로 @RequestParam 은 url 상에서 데이터를 찾기 때문이다.

우리가 위에서 <form> 태그를 이용하여 데이터를 입력하고 제출 버튼을 누르면 입력한 데이터들이 url을 통해서 전달된다.

 

예를 들면 'http://localhost:8080/receive?name=jun&age=13' 이런 식이다.

반면에 Json형식으로 데이터를 전달할때는, url은 http://localhost:8080/receive로 변함이 없고 body에 데이터를 포함하여 전송하기 때문에 @RequestParam 으로는 받을 수 없는 것이다.

--------------------------
이제 다시 본론으로 돌아와 '/receive' 주소로 데이터를 전송하고 @RequestBody 로 데이터를 받아보자.
@Controller
public class UserController {

	@PostMapping("/receive")
	public String age(@RequestBody String req) {
		System.out.println("통신 성공");
		System.out.println(">>> " + req);
		return "result";
	}
}

//출력 결과
//통신 성공
//>>> {"name":"jun","age":"13"}

<form> 태그로 데이터를 전달하고 @RequestBody 로 받았을 때와 차이가 없어 보인다.
하지만 여기에는 큰 차이가 있다.

----------------------
바로 자동 객체 생성이다
만약 다음과 같이 name 과 age 를 필요로 하는 Person 클래스가 있고 getter 가 구현되어 있다면

public class Person {
    private String name;
    private int age;

    public Person() {

    }

    public Person(final String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }

    @Override
    public String toString() {
        return "Person{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}

다음과 같은 기능이 가능하다.

@Controller
public class UserController {

	@PostMapping("/receive")
	public String age(@RequestBody Person person) {
		System.out.println("통신 성공");
		System.out.println(">>> " + person);
		return "result";
	}
}

//출력 결과
//통신 성공
//>>> Person{name='jun', age=13}

신기하게도 Person 객체를 자동으로 생성해 주었다.

@RequestBody 가 아닌 @RequestParam 을 이용한다면 불가능하다. 한번 시도해보자.
 

비동기통신에서 @RequestParam 으로 데이터를 전달받기 위해 fetch에서 /receive?name=jun&age=13 의 주소로 데이터를 전송하고 @RequestParam 으로 데이터를 받아 같은 행동을 취했지만 에러가 발생하는 모습이다.

@Controller
public class UserController {

	@PostMapping("/receive")
	public String age(@RequestParam Person person) {
		System.out.println("통신 성공");
		System.out.println(">>> " + person);
		return "result";
	}
}

//출력 결과
.MissingServletRequestParameterException: Required Person parameter 'person' is not present]

---------------------
@RequestBody, @RequestParam 모두 Map<String,String> 으로 결과를 받아올 수도 있다.

@Controller
public class UserController {

	@PostMapping("/receive")
	public String age(@RequestBody Map<String,String> map) {
		System.out.println("통신 성공");
		System.out.println(">>> " + map.get("name"));
		System.out.println(">>> " + map.get("age"));
		return "result";
	}
}

//출력 결과
//통신 성공
//>>> jun
//>>> 13
=========================================================================
HttpServletRequest
웹브라우저 사용자인 클라이언트로부터 서버로 요청이 들어오면 서버에서는 HttpServletRequest  를 생성하며, 
요청정보에 있는 패스로 매핑된 서블릿에게 전달합니다.

- 예를들어, 아이디, 비밀번호 등의 데이터를 컨트롤러로 보냈을 때, HttpServletRequest 객체안의 모든 데이터들이 들어가게된다.
- @RequestParam도 가능
- 원하는 데이터를 꺼낼때는 String id = httpServletRequest.getParameter("id");
- getParameter()메소드는 반환타입이 String이다.
- model객체를 이용해서 뷰로넘긴다.

@Controller
public class HomeController {
	@RequestMapping("/board/confirmId")
	public String confirmId(HttpServletRequest httpServletRequest, Model model) {
		String id = httpServletRequest.getParameter("id");
		String pwd = httpServletRequest.getParameter("pwd");
		model.addAttribute("id",id);
		model.addAttribute("pwd",pwd);
		return  "board/confirmId";
	}
}

또 다른 예)
<a href="/board/list.do?gubun=1">  //파라미터 전달
-------
@RequestMapping("/board/list.do")
public String list(HttpServletRequest request, Model model){
 
        
 
       String gubunValue = request.getParameter("gubun");
    
    
       model.addAttribute("gubunValue ", gubunValue );
 
        
 
       return "/board/list";
 
    }
=======================================================================
HTTP header - referer
리퍼러를 참조함으로써 현재 표시하는 웹페이지가 어떤 웹페이지에서 요청되었는지 알 수 있으며, 어떤 웹사이트나 웹서버에서 방문자가 왔는지를
파악할 수 있는 기능

[http://www.info19.com/1.html] 이라는 웹페이지에 있는 링크를 클릭하여 [http://www.info19.com/2.html] 으로 이동했을 때 
리퍼러는 [http://www.info19.com/1.html] 이 된다.


