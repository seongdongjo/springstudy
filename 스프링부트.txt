객체 지향 특성 - 추상화, 상속, 은닉, 재사용, 인터페이스 등

1. 캡슐화 : 객체의 속성을 보호하기위해사용 - getter,setter, crud메서드 등
- 장점 : 실제로 method가 어떻게 동작하는지 외부에서는 이해할 필요가없다. 
       재사용성 향상
	   유지보수 향상(하나의 객체안의 속성을 바꿔도 다른곳에는 영향x)
       무결성(변수는 private, 함수는 public)
2. 상속
- 최상위 클래스만 보고 하위클래스들이 어떤한 속성을 가지는지 확인 가능
- 재사용성 향상(상속받아서 사용)
- 유지보수 향상

3. 다형성(오버라이딩을 통해 알아서 찾아간다.)
4. 추상화(객체지향에서의 추상화는 모델링이다)

----------
객체지향설계 5원칙(SOLID)

결합도는 낮추고 응집도는 높여야한다.
결합도는 클래스간의 상호의존정도를 나타내는지표이다.
결합도가 낮으면 모듈(클래스)간의 상호의존성이 줄어들어서 객체 재사용 및 유지보수가 유리하다.

응집도는 모듈내부에서 구성요소들의 기능관련적으로 응집도가 높아야한다.

1. SRP(단일책임원칙)
//객체지향, 다형성 적용안시킬때
//이렇게 하면 유닛이 늘어나면 계속 else if써야되고 혹시나 잘못설정하면 move전체 메서드에 영향을 주게 된다.(단일책임)
class Unit {
	private String name,
	private int speed,
	
	public void attack() {
	}
	
	public void move() {
		if(name.equals("저글링")) {
			speed += 3
		}else if(name.equals("탱크")) {
			if("탱크모드") {
				speed = 0
			}else {
				speed = 10
			}
		}
	}
}

-----------------
//올바른 예 -> 각 기능을 분리함
class 저글링 extends Unit {
	public void move() {
		this.speed += 3
	}
}

class 탱크 extends Unit {
	public void move() {
		if("탱크모드") {
		
		}else {
		
		}
	}
}

class 정찰기 extends Unit {
	public void 정찰기() {
		this.충돌 = false;
	}
	public void move() {
		speed = 15
	}
}
===========================================================
2. OCP(개방폐쇄원칙)
- 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀있어야한다.(jdbc)
가운데에 jdbc인터페이스를 두고 바깥에는 oracle, mysql, h2, mariadb 등으로 확장가능

3. LSP(리스코프치환원칙)
- 서브타입은 언제나 자신의 기반(상위)타입으로 교체할 수있어야한다.

//LSP 위반 예시
       아반떼
	  /   \
    소나타  그렌저

//LSP 적용 예시
	   공중유닛/비행기
	  /         \
	정찰기		   수송기

4. ISP(인터페이스 분리원칙)
-프로젝트 요구사항과 설계에 따라서 SRP, ISP를 선택한다.
예) 지도에는 도보안내, 자동차안내, 바이크안내 등등의 메서드가 있는데 자전거내비는 자전거길안내메서드만 있으면 되는데 그거 하나 쓰겠다고 지도를 상속받으면 필요없는 메서드까지 사용하게될수있다.
그래서, 각 인터페이스를 만들고(자동차길안내, 자전거길안내 등) 자전거내비는 자전거길안내만 할수있게끔 하는게 인터페이스 분리원칙이다.  

5. DIP(의존역전원칙)
===============================================================
POJO JAVA
- 순수한 자바 오브젝트를 뜻한다.
1. 특정 규약에 종속되지 않는다.
특정 라이브러리, 모듈에서 정의된 클래스를 상속받아서 구현하지 않아도 된다.
POJO가 되기 위해서는 외부의 의존성을 두지않고, 순수한 JAVA로 구성이 가능해야한다.

2. 특정 환경에 종속되지 않는다.
http request, session 등 POJO를 위배한것으로 간주
@Annotation 기반으로 설정하는 부분도 엄연히 POJO 라고 볼수는 없다.

POJO Framework
- spring, Hibernate
POJO를 지향하는 프레임워크이다.
개발자가 서비스 로직에 집중하고 이를 POJO로 쉽게 개발할수있도록 지원하고있다.

====================================================================
//디자인패턴
자주 사용하는 설계 패턴을 정형화해서 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계
-싱글톤패턴
하나의 프린터를 연결할 때(동일한 객체를 얻는다)
package com.company.singleton;

public class AClazz {
    private SocketClient socketClient;

    public AClazz() {
        this.socketClient = SocketClient.getInstance();
        //this.socketClient = new SocketClient(); 이렇게하면 새로운객체만듬
    }
    public SocketClient getSocketClient() {
        return this.socketClient;
    }
}
--------------
package com.company.singleton;

public class BClazz {
    private SocketClient socketClient;

    public BClazz() {
        this.socketClient = SocketClient.getInstance();
    }
    public SocketClient getSocketClient() {
        return this.socketClient;
    }
---------------
package com.company.singleton;

public class SocketClient {
    private static SocketClient socketClient = null;

    //public socketClient() { 이렇게 새로 객체를 만들면 서로 객체가다르다 AClazz참조
    //}
    private SocketClient() { //기본생성자 막고

    }

    public static SocketClient getInstance() { //최초에 한번만 생성
        if(socketClient == null) {
            socketClient = new SocketClient();
        }
        return socketClient;
    }

    public void connect() {
        System.out.println("connect");
    }
------------------
package com.company;

import com.company.adapter.*;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

public class Main {

    public static void main(String[] args) {
        AClazz aClazz = new AClazz();
        BClazz bClazz = new BClazz();

        SocketClient aClient = aClazz.getSocketClient();
        SocketClient bClient = bClazz.getSocketClient();

        System.out.println("두개의 객체가 동일한가");
        System.out.println(aClient.equals(bClient));

    }

}
====================================================================================
-어댑터 패턴
호환성이 없는 기존 클래스의 인터페이스를 변환하여 재사용 할 수 있도록 한다.
OCP(개방퍠쇄원칙)을 따른다.

package com.company.adapter;

public interface Electronic110V {
    void powerOn();
}
-------------
package com.company.adapter;

public interface Electronic220V {
    void connect();
}
--------------
package com.company.adapter;

public class AirConditioner implements Electronic220V{
    @Override
    public void connect() {
        System.out.println("에어컨 220V");
    }
}
----------------
package com.company.adapter;

public class Cleaner implements Electronic220V{
    @Override
    public void connect() {
        System.out.println("청소기 220V");
    }
}
---------------
package com.company.adapter;

public class HairDryer implements Electronic110V{
    @Override
    public void powerOn() {
        System.out.println("헤어드라이기 110V");
    }
---------------
package com.company.adapter;

public class SocketAdapter implements Electronic110V{

    private Electronic220V electronic220V;

    public SocketAdapter(Electronic220V electronic220V) {
        this.electronic220V = electronic220V;
    }

    @Override
    public void powerOn() {
        electronic220V.connect();
    }
------------------
package com.company;

import com.company.adapter.*;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

public class Main {

    public static void main(String[] args) {
     
        HairDryer hairDryer = new HairDryer();
        connect(hairDryer); //출력: 헤어드라이어 110V

        Cleaner cleaner = new Cleaner();
        //connect(cleaner); 이렇게하면에러가난다. 현재 connect메서드는 110V만 연결가능하다.
        //그래서 어댑터가 필요.(220 -> 110v로 바꿔주는)

        Electronic110V adapter = new SocketAdapter(cleaner); //220v을 어댑터를 통해 연결
        connect(adapter);
        //인터페이스가 서로달라서 맞추지못할때(110,220v) 중간에서 어댑터클래스를 통해 연결 -> 어댑터 패턴

        AirConditioner airConditioner = new AirConditioner();
        Electronic110V airAdapter = new SocketAdapter(airConditioner);
        connect(airAdapter);
        
    }
    //콘센트
    //main함수가 static이니까 여기도 static
    public static void connect(Electronic110V electronic110V) {
        electronic110V.powerOn();
    }

}
====================================================================================
//프록시패턴
package com.company.proxy;

public interface IBrowser {
    Html show();
}
---------------
package com.company.proxy;

public class Html {
    private String url;

    public Html(String url) {
        this.url = url;
    }
}
---------------
package com.company.proxy;

public class Browser implements IBrowser{
    private String url;
    
    public Browser(String url){
        this.url = url;
    }

    @Override
    public Html show() {
        System.out.println("browser loading html from: " + url);
        return new Html(url); //url접근시 html파일만들어서 반환
    }
}
-------------------
package com.company.proxy;

public class BrowserProxy implements IBrowser{
    private String url;
    private Html html;

    public BrowserProxy(String url) {
        this.url = url;
    }

    @Override
    public Html show() {
        if(html == null) {
            this.html = new Html(url);
            System.out.println("BrowserProxy loading html from: " + url);
        }

        System.out.println("BrowserProxy use cache html: " + url);
        return html;
    }
}
------------------
package com.company.aop;

import com.company.proxy.Html;
import com.company.proxy.IBrowser;

public class AopBrowser implements IBrowser {
    private String url;
    private Html html;
    private Runnable before;
    private Runnable after;

    public AopBrowser(String url, Runnable before, Runnable after) {
        this.url = url;
        this.before = before;
        this.after = after;
    }

    //Aop는 관점기준이라 before,after로 비슷하게 해봄
   @Override
    public Html show() {
       before.run(); //전후로 내가 원하는 기능넣을것이다.

       if(html == null) {
           this.html = new Html(url);
           System.out.println("AopBrowser html loading from: " + url);
           try {
               Thread.sleep(1500);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
       after.run();
       System.out.println("AopBrowser html cache: " +url);
       return html;
    }
}
--------------------------
package com.company;

import com.company.adapter.*;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

public class Main {

    public static void main(String[] args) {

        Browser browser = new Browser("www.naver.com");
        browser.show(); //html파일하나 받는다. 출력: browser loading html from : www.naver.com
        browser.show();
        browser.show();
        browser.show(); //캐시를 사용안하면 새로 계속 html을 생성한다.

        //프록시를 통해호출
        IBrowser browser1 = new BrowserProxy("www.naver.com"); //처음은 html을 생성
        browser.show(); //여기서부터는 cache를 이용함
        browser.show();
        browser.show();
        browser.show();
        browser.show();

		AtomicLong start = new AtomicLong();
        AtomicLong end = new AtomicLong();
        IBrowser aopBrowser = new AopBrowser("www.naver.com",
                () -> {
                    System.out.println("before");
                    start.set(System.currentTimeMillis());
                },
                () -> {
                    long now = System.currentTimeMillis();
                    end.set(now - start.get()); //몇초걸렸는지 end에 들어간다.
                }

        );
        aopBrowser.show(); //처음에는 생성쪽에 1.5초 delay줬으니 1.5초걸리고
        System.out.println("loading time: " + end.get());

        aopBrowser.show(); //두번쨰 호출부터는 loadingtime이 0이다.
        System.out.println("loading time: " + end.get());

    }

}
===============================================================================
//데코레이터 패턴 : 기존 뼈대(클래스)는 유지하되, 이후필요한 형태로 꾸밀 때 사용
ex)커피원액에 물을 넣으면 아메리카노, 거기에 우유를 넣으면 라떼 ...
즉, 원본을 유지하되 첨가되는거
package com.company.decorator;

public interface ICar {
    int getPrice();
    void showPrice(); //금액을 출력
}

--------------
package com.company.decorator;

public class Audi implements ICar{

    private int price;

    public Audi(int price) {
        this.price = price;
    }
    @Override
    public int getPrice() {
        return price;
    }

    @Override
    public void showPrice() {
        System.out.println("audi 의 가격은 "+this.price+"원 입니다.");
    }
}
--------------
package com.company.decorator;

public class A3 extends AudiDecorator{
    public A3(ICar audi, String modelName) {
        super(audi, modelName, 1000);
    }
}
---------------
package com.company.decorator;

public class A4 extends AudiDecorator{
    public A4(ICar audi, String modelName) {
        super(audi, modelName, 2000);
    }
}
-----------------
package com.company.decorator;

public class A5 extends AudiDecorator{
    public A5(ICar audi, String modelName) {
        super(audi, modelName, 3000);
    }
}
------------------
package com.company.decorator;

public class AudiDecorator implements ICar{ //a3,a4,a5에게 전달받음
    protected ICar audi;
    protected String modelName;
    protected int modelPrice;

    public AudiDecorator(ICar audi, String modelName, int modelPrice) {
        this.audi = audi;
        this.modelName = modelName;
        this.modelPrice = modelPrice;
    }

    @Override
    public int getPrice() {
        return audi.getPrice() + modelPrice;
    }

    @Override
    public void showPrice() {
        System.out.println(modelName + "의 가격은"+getPrice()+"원 입니다."); //getPrice는 audi + model가격
    }
}
---------------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {

        ICar audi = new Audi(1000);
        audi.showPrice();

        //등급에따라 가격이 증가
        //a3
        ICar audi3 = new A3(audi, "A3");
        audi3.showPrice();
        //a4
        ICar audi4 = new A4(audi, "A4");
        audi4.showPrice();
        //a5
        ICar audi5 = new A5(audi, "A5");
        audi5.showPrice();

    }
}
===========================================================================
//옵저버 패턴: 변화가 일어났을떄, 미리 등록된 이벤트를 다른 클래스에 통보해주는 패턴을 구현하는 것이다.(event listener에서 해당패턴을 사용하고있다)
ex)교실에서 망을보다가 선생님오시면 이벤트전달해주는 역할

package com.company.observer;

public interface IButtonListener {
    void clickEvent(String event);
}
------------
package com.company.observer;

public class Button {
    private String name;
    private IButtonListener buttonListener;

    public Button(String name) {
        this.name = name;
    }
    public void click(String message) {
        buttonListener.clickEvent(message);
    }
    public void addListener(IButtonListener buttonListener) {
        this.buttonListener = buttonListener;
    }
}
--------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {

        Button button = new Button("버튼");

        button.addListener(new IButtonListener() { //익명클래스
            @Override
            public void clickEvent(String event) {
                System.out.println(event);
            }
        });

        button.click("메시지 전달: click1"); //이벤트를 위에 전달해주는
        button.click("메시지 전달: click2");
        button.click("메시지 전달: click3");
        button.click("메시지 전달: click4");

    }
}
============================================================================
//퍼싸드 패턴
	client
/  		|     \
ftp writer reader

이거를

	  client
	    |
	  facade
/  		|     \
ftp writer reader


//퍼싸드 적용 전 예시
package com.company.facade;

public class Ftp {
    private String host;
    private int port;
    private String path;

    public Ftp(String host, int port, String path) {
        this.host = host;
        this.port = port;
        this.path = path;
    }
    public void connect() {
        System.out.println("FTP Host: " + host + "Port : " +port+ "로 연결합니다.");
    }
    public void moveDirectory() {
        System.out.println("FTP path: " + path+"로 이동합니다.");
    }
    public void dicConnect() {
        System.out.println("FTP 연결을 종료합니다.");
    }
}

-----------------
package com.company.facade;

public class Writer { //파일쓰기
    private String fileName;
    
    public Writer(String fileName) {
        this.fileName = fileName;
    }
    
    public void fileConnect() { //파일 생성또는 이어쓰기
        String msg = String.format("Writer %s로 연결합니다.",fileName);
        System.out.println(msg);
    }
    
    public void fileDisconnect() {
        String msg = String.format("Writer %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
    
    public void write() {
        String msg = String.format("Writer %s로 파일쓰기를 합니다.",fileName);
        System.out.println(msg);
    }
}
--------------------
package com.company.facade;

public class Reader { //파일에서 읽어오기때문에 파일이름을 알아야한다.
    private String fileName;

    public Reader(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Reader %s로 연결합니다.",fileName);
        System.out.println(msg);
    }

    public void fileRead() {
        String msg = String.format("Reader %s의 내용을 읽어옵니다.",fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Reader %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
}
----------------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.facade.Ftp;
import com.company.facade.Reader;
import com.company.facade.Writer;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {
        Ftp ftpClient = new Ftp("www.foo.co.kr", 22, "/home/etc");
        ftpClient.connect();
        ftpClient.moveDirectory();

        Writer writer = new Writer("text.tmp");
        writer.fileConnect();
        writer.write();

        Reader reader = new Reader("text.tmp");
        reader.fileConnect();
        reader.fileRead();

        reader.fileDisconnect();
        writer.fileDisconnect();
        ftpClient.dicConnect();
    }
}
===============================================================================
//퍼싸드 적용 후 예시
package com.company.facade;

public class Ftp {
    private String host;
    private int port;
    private String path;

    public Ftp(String host, int port, String path) {
        this.host = host;
        this.port = port;
        this.path = path;
    }
    public void connect() {
        System.out.println("FTP Host: " + host + "Port : " +port+ "로 연결합니다.");
    }
    public void moveDirectory() {
        System.out.println("FTP path: " + path+"로 이동합니다.");
    }
    public void dicConnect() {
        System.out.println("FTP 연결을 종료합니다.");
    }
}

-----------------
package com.company.facade;

public class Writer { //파일쓰기
    private String fileName;
    
    public Writer(String fileName) {
        this.fileName = fileName;
    }
    
    public void fileConnect() { //파일 생성또는 이어쓰기
        String msg = String.format("Writer %s로 연결합니다.",fileName);
        System.out.println(msg);
    }
    
    public void fileDisconnect() {
        String msg = String.format("Writer %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
    
    public void write() {
        String msg = String.format("Writer %s로 파일쓰기를 합니다.",fileName);
        System.out.println(msg);
    }
}
--------------------
package com.company.facade;

public class Reader { //파일에서 읽어오기때문에 파일이름을 알아야한다.
    private String fileName;

    public Reader(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Reader %s로 연결합니다.",fileName);
        System.out.println(msg);
    }

    public void fileRead() {
        String msg = String.format("Reader %s의 내용을 읽어옵니다.",fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Reader %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
}
----------------------
package com.company.facade;

public class SftpClient {
    private Ftp ftp;
    private Reader reader;
    private Writer writer;

    public SftpClient(Ftp ftp, Reader reader, Writer writer) { //두가지방법
        this.ftp = ftp;
        this.reader = reader;
        this.writer = writer;
    }
    //오버로딩
    public SftpClient(String host, int port, String path, String fileName) {
        this.ftp = new Ftp(host,port,path);
        this.reader = new Reader(fileName);
        this.writer = new Writer(fileName);
    }

    public void connect() {
        ftp.connect();
        ftp.moveDirectory();
        writer.fileConnect();
        reader.fileConnect();
    }
    public void disConnect() {
        writer.fileDisconnect();
        reader.fileDisconnect();
        ftp.dicConnect();
    }

    public void read() {
        reader.fileRead();
    }
    public void write() {
        writer.write();
    }
}
------------------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.facade.Ftp;
import com.company.facade.Reader;
import com.company.facade.Writer;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {
        Ftp ftpClient = new Ftp("www.foo.co.kr", 22, "/home/etc");
        ftpClient.connect();
        ftpClient.moveDirectory();

        Writer writer = new Writer("text.tmp");
        writer.fileConnect();
        writer.write();

        Reader reader = new Reader("text.tmp");
        reader.fileConnect();
        reader.fileRead();

        reader.fileDisconnect();
        writer.fileDisconnect();
        ftpClient.dicConnect();
		
	   SftpClient sftpClient = new SftpClient("www.foo.co.kr", 22, "/home/etc", "text.tmp");
       sftpClient.connect();
       sftpClient.write();
       sftpClient.read();
       sftpClient.disConnect();
       //객체들의 의존을 숨기는게 퍼싸드패턴이다.
    }
}
===================================================================================
//전략패턴
유사한 행위들을 캡슐화하여, 객체의 행위를 바꾸고 싶은 경우 직접 변경하는 것이 아닌 전략만 변경하여, 유연하게 확장하는 패턴
package com.company.strategy;

public interface EncodingStrategy {
    String encode(String text);
}
------------
package com.company.strategy;

public class AppendStrategy implements EncodingStrategy{

    @Override
    public String encode(String text) {
        return "ABCD" + text; //abcd를 추가시키는
    }
}
--------------
package com.company.strategy;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class Base64Strategy implements EncodingStrategy{

    @Override
    public String encode(String text) {
        return Base64.getEncoder().encodeToString(text.getBytes()); //인코딩하기
    }
}
---------------
package com.company.strategy;

public class Encoder { //그떄그때마다 전략을 받아야한다. 어떤 인코드를 쓸지
    private EncodingStrategy encodingStrategy;

    public String getMessage(String message) {
        return this.encodingStrategy.encode(message);
    }

    public void setEncodingStrategy(EncodingStrategy encodingStrategy) {
        this.encodingStrategy = encodingStrategy;
    }
}
-----------------
package com.company.strategy;

public class NormalStrategy implements EncodingStrategy{
    @Override
    public String encode(String text) {
        return text;
    }
}
----------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.facade.Ftp;
import com.company.facade.Reader;
import com.company.facade.SftpClient;
import com.company.facade.Writer;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;
import com.company.strategy.*;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {


        //전략 메서드를 가진 전략객체(NormalStrategy, Base64Strategy)
        //전략 객체를 사용하는 컨텍스트(Encoder)
        //전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(main)

        Encoder encoder = new Encoder();

        //base64전략 생성
        EncodingStrategy base64 = new Base64Strategy();

        //normal전략생성
        EncodingStrategy normal = new NormalStrategy();

        String message = "hello java";
        //전략수정(원본객체는 그대로 두고)
        encoder.setEncodingStrategy(base64);
        String base64Result = encoder.getMessage(message);
        System.out.println(base64Result); //출력: aGVsbG8gamF2YQ==

        encoder.setEncodingStrategy(normal);
        String normalResult = encoder.getMessage(message);
        System.out.println(normalResult); //출력: hello java

        encoder.setEncodingStrategy(new AppendStrategy());
        String appendResult = encoder.getMessage(message);
        System.out.println(appendResult); //출력: ABCDhello java
    }
}
=========================================================================