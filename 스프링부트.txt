객체 지향 특성 - 추상화, 상속, 은닉, 재사용, 인터페이스 등

1. 캡슐화 : 객체의 속성을 보호하기위해사용 - getter,setter, crud메서드 등
- 장점 : 실제로 method가 어떻게 동작하는지 외부에서는 이해할 필요가없다. 
       재사용성 향상
	   유지보수 향상(하나의 객체안의 속성을 바꿔도 다른곳에는 영향x)
       무결성(변수는 private, 함수는 public)
2. 상속
- 최상위 클래스만 보고 하위클래스들이 어떤한 속성을 가지는지 확인 가능
- 재사용성 향상(상속받아서 사용)
- 유지보수 향상

3. 다형성(오버라이딩을 통해 알아서 찾아간다.)
4. 추상화(객체지향에서의 추상화는 모델링이다)

----------
객체지향설계 5원칙(SOLID)

결합도는 낮추고 응집도는 높여야한다.
결합도는 클래스간의 상호의존정도를 나타내는지표이다.
결합도가 낮으면 모듈(클래스)간의 상호의존성이 줄어들어서 객체 재사용 및 유지보수가 유리하다.

응집도는 모듈내부에서 구성요소들의 기능관련적으로 응집도가 높아야한다.

1. SRP(단일책임원칙)
//객체지향, 다형성 적용안시킬때
//이렇게 하면 유닛이 늘어나면 계속 else if써야되고 혹시나 잘못설정하면 move전체 메서드에 영향을 주게 된다.(단일책임)
class Unit {
	private String name,
	private int speed,
	
	public void attack() {
	}
	
	public void move() {
		if(name.equals("저글링")) {
			speed += 3
		}else if(name.equals("탱크")) {
			if("탱크모드") {
				speed = 0
			}else {
				speed = 10
			}
		}
	}
}

-----------------
//올바른 예 -> 각 기능을 분리함
class 저글링 extends Unit {
	public void move() {
		this.speed += 3
	}
}

class 탱크 extends Unit {
	public void move() {
		if("탱크모드") {
		
		}else {
		
		}
	}
}

class 정찰기 extends Unit {
	public void 정찰기() {
		this.충돌 = false;
	}
	public void move() {
		speed = 15
	}
}
===========================================================
2. OCP(개방폐쇄원칙)
- 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀있어야한다.(jdbc)
가운데에 jdbc인터페이스를 두고 바깥에는 oracle, mysql, h2, mariadb 등으로 확장가능
- 예를들어, java프로그램은 어떤 운영체제에서도 JVM을 통해 동일하게 실행된다.(java는 OS에 개방적이다)
- 다르게 표현하면, java프로그램언어는 운영체제가 변경되더라도 영향을 받지 않는다.
(java는 OS변경에 영향을 받지않는다. OS변경에 닫혀있다)

- 또 예를들어, Jdbc는 데이터 커넥션 부분만 변경하면, 어떤 dB에서도 동일하게 사용할 수 있다.(JDBC는 db에 개방적이다)
- 다르게 표현하면, jdbc는 db가 중간에 변경되더라도 영향을 받지 않게 설계되어 있다.
(jdbc는 db의 변경에 닫혀있다)

- 또 예를들어, 나는 자동차 운전을 할 수 있다. 소나타, 그랜저, bmw 등
(나는 자동차 운전에 개방적이다)
- 다르게 표현하면, 나는 자동차가 바뀌더라도 영향을 받지 않는다.
- 즉 자동차가 바뀌더라도 내가 운전하는 방식은 동일해야한다.

//잘못된 예
운전자--- 소나타(method운전하다())
운전자--- 그랜저(method운전하다())
운전자--- BMW(method운전하다())

//올바른 예
운전자 ---- 자동차(method운전하다())
           |
		---|--------------
		|  		 |    	 |
	  소나타 		그랜저 	BMW
    (override   (override)   
  method운전하다()) 운전하다()

//잘못된 예
package book.oopforsprings.lec05.solid;

public class OCP운전자_NO {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		소나타2 운전자 = new 소나타2();
		  운전자.drive();
		
		그랜저2 운전자2 = new 그랜저2();
		  운전자2.drive();
		
		BMW2 운전자3 = new BMW2();
		  운전자3.drive();
	}

}

class 소나타2{	
	void drive() {
		System.out.println("나는 소나타를 운전한다.");
	}
}

class 그랜저2{	
	void drive() {
		System.out.println("나는 그랜저를 운전한다.");
	}
}

class BMW2{	
	void drive() {
		System.out.println("나는 BMW를 운전한다.");
	}
}

//올바른 예(확장이 쉽게)
package book.oopforsprings.lec05.solid;

public class OCP운전자_OK {

	public static void main(String[] args) {
		
		자동차[] 운전자 = new 자동차[3];
		
		운전자[0] = new 소나타();
		운전자[1] = new 그랜저();
		운전자[2] = new BMW();
		
		for(int i=0; i<운전자.length; i++) {
			운전자[i].drive();
		}

	}

}

class 자동차{
	String myCar="자동차";
	void drive() {
		System.out.printf("나는 %s 를 운전할 수 있다. \n",  myCar);
	}
}

class 소나타 extends 자동차{
	public 소나타() {
		myCar = "소나타";
	}	
}

class 그랜저 extends 자동차{	
	public 그랜저() {
		myCar = "그랜저";
	}
}

class BMW extends 자동차{	
	public BMW() {
		myCar = "BMW";
	}
}

  
3. LSP(리스코프치환원칙)
- 서브타입은 언제나 자신의 기반(상위)타입으로 교체할 수있어야한다.

//LSP 위반 예시
       아반떼
	  /   \
    소나타  그렌저

//LSP 적용 예시
	   공중유닛/비행기
	  /         \
	정찰기		   수송기

4. ISP(인터페이스 분리원칙)
-프로젝트 요구사항과 설계에 따라서 SRP, ISP를 선택한다.
예) 지도에는 도보안내, 자동차안내, 바이크안내 등등의 메서드가 있는데 자전거내비는 자전거길안내메서드만 있으면 되는데 그거 하나 쓰겠다고 지도를 상속받으면 필요없는 메서드까지 사용하게될수있다.
그래서, 각 인터페이스를 만들고(자동차길안내, 자전거길안내 등) 자전거내비는 자전거길안내만 할수있게끔 하는게 인터페이스 분리원칙이다.  

5. DIP(의존역전원칙)
===============================================================
POJO JAVA
- 순수한 자바 오브젝트를 뜻한다.
1. 특정 규약에 종속되지 않는다.
특정 라이브러리, 모듈에서 정의된 클래스를 상속받아서 구현하지 않아도 된다.
POJO가 되기 위해서는 외부의 의존성을 두지않고, 순수한 JAVA로 구성이 가능해야한다.

2. 특정 환경에 종속되지 않는다.
http request, session 등 POJO를 위배한것으로 간주
@Annotation 기반으로 설정하는 부분도 엄연히 POJO 라고 볼수는 없다.

POJO Framework
- spring, Hibernate
POJO를 지향하는 프레임워크이다.
개발자가 서비스 로직에 집중하고 이를 POJO로 쉽게 개발할수있도록 지원하고있다.

====================================================================
//디자인패턴
자주 사용하는 설계 패턴을 정형화해서 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계
-싱글톤패턴
하나의 프린터를 연결할 때(동일한 객체를 얻는다)
package com.company.singleton;

public class AClazz {
    private SocketClient socketClient;

    public AClazz() { //기본생성자
        this.socketClient = SocketClient.getInstance();
        //this.socketClient = new SocketClient(); 이렇게하면 새로운객체만듬
    }
    public SocketClient getSocketClient() {
        return this.socketClient;
    }
}
--------------
package com.company.singleton;

public class BClazz {
    private SocketClient socketClient;

    public BClazz() { //기본생성자
        this.socketClient = SocketClient.getInstance();
    }
    public SocketClient getSocketClient() {
        return this.socketClient;
    }
---------------
package com.company.singleton;

public class SocketClient {
    private static SocketClient socketClient = null;

    //public socketClient() { 이렇게 새로 객체를 만들면 서로 객체가다르다 AClazz참조
    //}
    private SocketClient() { //기본생성자 막고

    }

    public static SocketClient getInstance() { //최초에 한번만 생성
        if(socketClient == null) {
            socketClient = new SocketClient();
        }
        return socketClient;
    }

    public void connect() {
        System.out.println("connect");
    }
------------------
package com.company;

import com.company.adapter.*;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

public class Main {

    public static void main(String[] args) {
        AClazz aClazz = new AClazz();
        BClazz bClazz = new BClazz();

        SocketClient aClient = aClazz.getSocketClient();
        SocketClient bClient = bClazz.getSocketClient();

        System.out.println("두개의 객체가 동일한가");
        System.out.println(aClient.equals(bClient));

    }

}
====================================================================================
-어댑터 패턴
호환성이 없는 기존 클래스의 인터페이스를 변환하여 재사용 할 수 있도록 한다.
OCP(개방퍠쇄원칙)을 따른다.

package com.company.adapter;

public interface Electronic110V {
    void powerOn();
}
-------------
package com.company.adapter;

public interface Electronic220V {
    void connect();
}
--------------
package com.company.adapter;

public class AirConditioner implements Electronic220V{
    @Override
    public void connect() {
        System.out.println("에어컨 220V");
    }
}
----------------
package com.company.adapter;

public class Cleaner implements Electronic220V{
    @Override
    public void connect() {
        System.out.println("청소기 220V");
    }
}
---------------
package com.company.adapter;

public class HairDryer implements Electronic110V{
    @Override
    public void powerOn() {
        System.out.println("헤어드라이기 110V");
    }
---------------
package com.company.adapter;

public class SocketAdapter implements Electronic110V{ //110을 220으로 변환하는 어댑터

    private Electronic220V electronic220V;

    public SocketAdapter(Electronic220V electronic220V) { //생성자
        this.electronic220V = electronic220V;
    }

    @Override
    public void powerOn() {
        electronic220V.connect();
    }
------------------
package com.company;

import com.company.adapter.*;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

public class Main {

    public static void main(String[] args) {
     
        HairDryer hairDryer = new HairDryer();
        connect(hairDryer); //출력: 헤어드라이어 110V

        Cleaner cleaner = new Cleaner();
        //connect(cleaner); 이렇게하면에러가난다. 현재 connect메서드는 110V만 연결가능하다.
        //그래서 어댑터가 필요.(220 -> 110v로 바꿔주는)

        Electronic110V adapter = new SocketAdapter(cleaner); //220v을 어댑터를 통해 연결
        connect(adapter);
        //인터페이스가 서로달라서 맞추지못할때(110,220v) 중간에서 어댑터클래스를 통해 연결 -> 어댑터 패턴

        AirConditioner airConditioner = new AirConditioner();
        Electronic110V airAdapter = new SocketAdapter(airConditioner);
        connect(airAdapter); //에어컨 220V
        
    }
    //콘센트
    //main함수가 static이니까 여기도 static
    public static void connect(Electronic110V electronic110V) {
        electronic110V.powerOn();
    }

}
====================================================================================
//프록시패턴
package com.company.proxy;

public interface IBrowser {
    Html show();
}
---------------
package com.company.proxy;

public class Html {
    private String url;

    public Html(String url) { //생성자
        this.url = url;
    }
}
---------------
package com.company.proxy;

public class Browser implements IBrowser{
    private String url;
    
    public Browser(String url){
        this.url = url;
    }

    @Override
    public Html show() {
        System.out.println("browser loading html from: " + url);
        return new Html(url); //url접근시 html파일만들어서 반환
    }
}
-------------------
package com.company.proxy;

public class BrowserProxy implements IBrowser{
    private String url;
    private Html html;

    public BrowserProxy(String url) {
        this.url = url;
    }

    @Override
    public Html show() {
        if(html == null) {
            this.html = new Html(url);
            System.out.println("BrowserProxy loading html from: " + url);
        }

        System.out.println("BrowserProxy use cache html: " + url);
        return html;
    }
}
------------------
package com.company.aop;

import com.company.proxy.Html;
import com.company.proxy.IBrowser;

public class AopBrowser implements IBrowser {
    private String url;
    private Html html;
    private Runnable before;
    private Runnable after;

    public AopBrowser(String url, Runnable before, Runnable after) {
        this.url = url;
        this.before = before;
        this.after = after;
    }

    //Aop는 관점기준이라 before,after로 비슷하게 해봄
   @Override
    public Html show() {
       before.run(); //전후로 내가 원하는 기능넣을것이다.

       if(html == null) {
           this.html = new Html(url);
           System.out.println("AopBrowser html loading from: " + url);
           try {
               Thread.sleep(1500);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
       after.run();
       System.out.println("AopBrowser html cache: " +url);
       return html;
    }
}
--------------------------
package com.company;

import com.company.adapter.*;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

public class Main {

    public static void main(String[] args) {

        Browser browser = new Browser("www.naver.com");
        browser.show(); //html파일하나 받는다. 출력: browser loading html from : www.naver.com
        browser.show();
        browser.show();
        browser.show(); //캐시를 사용안하면 새로 계속 html을 생성한다.

        //프록시를 통해호출
        IBrowser browser1 = new BrowserProxy("www.naver.com"); //처음은 html을 생성
        browser.show(); //여기서부터는 cache를 이용함
        browser.show();
        browser.show();
        browser.show();
        browser.show();

		AtomicLong start = new AtomicLong();
        AtomicLong end = new AtomicLong();
        IBrowser aopBrowser = new AopBrowser("www.naver.com",
                () -> {
                    System.out.println("before");
                    start.set(System.currentTimeMillis());
                },
                () -> {
                    long now = System.currentTimeMillis();
                    end.set(now - start.get()); //몇초걸렸는지 end에 들어간다.
                }

        );
        aopBrowser.show(); //처음에는 생성쪽에 1.5초 delay줬으니 1.5초걸리고
        System.out.println("loading time: " + end.get());

        aopBrowser.show(); //두번쨰 호출부터는 loadingtime이 0이다.
        System.out.println("loading time: " + end.get());

    }

}
===============================================================================
//데코레이터 패턴 : 기존 뼈대(클래스)는 유지하되, 이후필요한 형태로 꾸밀 때 사용
ex)커피원액에 물을 넣으면 아메리카노, 거기에 우유를 넣으면 라떼 ...
즉, 원본을 유지하되 첨가되는거
package com.company.decorator;

public interface ICar {
    int getPrice();
    void showPrice(); //금액을 출력
}

--------------
package com.company.decorator;

public class Audi implements ICar{

    private int price;

    public Audi(int price) {
        this.price = price;
    }
    @Override
    public int getPrice() {
        return price;
    }

    @Override
    public void showPrice() {
        System.out.println("audi 의 가격은 "+this.price+"원 입니다.");
    }
}
--------------
package com.company.decorator;

public class A3 extends AudiDecorator{
    public A3(ICar audi, String modelName) {
        super(audi, modelName, 1000);
    }
}
---------------
package com.company.decorator;

public class A4 extends AudiDecorator{
    public A4(ICar audi, String modelName) {
        super(audi, modelName, 2000);
    }
}
-----------------
package com.company.decorator;

public class A5 extends AudiDecorator{
    public A5(ICar audi, String modelName) {
        super(audi, modelName, 3000);
    }
}
------------------
package com.company.decorator;

public class AudiDecorator implements ICar{ //a3,a4,a5에게 전달받음
    protected ICar audi;
    protected String modelName;
    protected int modelPrice;

    public AudiDecorator(ICar audi, String modelName, int modelPrice) {
        this.audi = audi;
        this.modelName = modelName;
        this.modelPrice = modelPrice;
    }

    @Override
    public int getPrice() {
        return audi.getPrice() + modelPrice;
    }

    @Override
    public void showPrice() {
        System.out.println(modelName + "의 가격은"+getPrice()+"원 입니다."); //getPrice는 audi + model가격
    }
}
---------------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {

        ICar audi = new Audi(1000);
        audi.showPrice();

        //등급에따라 가격이 증가
        //a3
        ICar audi3 = new A3(audi, "A3");
        audi3.showPrice();
        //a4
        ICar audi4 = new A4(audi, "A4");
        audi4.showPrice();
        //a5
        ICar audi5 = new A5(audi, "A5");
        audi5.showPrice();

    }
}
===========================================================================
//옵저버 패턴: 변화가 일어났을떄, 미리 등록된 이벤트를 다른 클래스에 통보해주는 패턴을 구현하는 것이다.(event listener에서 해당패턴을 사용하고있다)
ex)교실에서 망을보다가 선생님오시면 이벤트전달해주는 역할

package com.company.observer;

public interface IButtonListener {
    void clickEvent(String event);
}
------------
package com.company.observer;

public class Button {
    private String name;
    private IButtonListener buttonListener;

    public Button(String name) { //1
        this.name = name;
    }
    public void click(String message) { //3
        buttonListener.clickEvent(message);
    }
    public void addListener(IButtonListener buttonListener) { //2
        this.buttonListener = buttonListener;
    }
}
--------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {

        Button button = new Button("버튼");

        button.addListener(new IButtonListener() { //익명클래스
            @Override
            public void clickEvent(String event) {
                System.out.println(event);
            }
        });

        button.click("메시지 전달: click1"); //이벤트를 위에 전달해주는
        button.click("메시지 전달: click2");
        button.click("메시지 전달: click3");
        button.click("메시지 전달: click4");

    }
}
============================================================================
//퍼싸드 패턴
	client
/  		|     \
ftp writer reader

이거를

	  client
	    |
	  facade
/  		|     \
ftp writer reader


//퍼싸드 적용 전 예시
package com.company.facade;

public class Ftp {
    private String host;
    private int port;
    private String path;

    public Ftp(String host, int port, String path) {
        this.host = host;
        this.port = port;
        this.path = path;
    }
    public void connect() {
        System.out.println("FTP Host: " + host + "Port : " +port+ "로 연결합니다.");
    }
    public void moveDirectory() {
        System.out.println("FTP path: " + path+"로 이동합니다.");
    }
    public void dicConnect() {
        System.out.println("FTP 연결을 종료합니다.");
    }
}

-----------------
package com.company.facade;

public class Writer { //파일쓰기
    private String fileName;
    
    public Writer(String fileName) {
        this.fileName = fileName;
    }
    
    public void fileConnect() { //파일 생성또는 이어쓰기
        String msg = String.format("Writer %s로 연결합니다.",fileName);
        System.out.println(msg);
    }
    
    public void fileDisconnect() {
        String msg = String.format("Writer %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
    
    public void write() {
        String msg = String.format("Writer %s로 파일쓰기를 합니다.",fileName);
        System.out.println(msg);
    }
}
--------------------
package com.company.facade;

public class Reader { //파일에서 읽어오기때문에 파일이름을 알아야한다.
    private String fileName;

    public Reader(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Reader %s로 연결합니다.",fileName);
        System.out.println(msg);
    }

    public void fileRead() {
        String msg = String.format("Reader %s의 내용을 읽어옵니다.",fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Reader %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
}
----------------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.facade.Ftp;
import com.company.facade.Reader;
import com.company.facade.Writer;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {
        Ftp ftpClient = new Ftp("www.foo.co.kr", 22, "/home/etc");
        ftpClient.connect();
        ftpClient.moveDirectory();

        Writer writer = new Writer("text.tmp");
        writer.fileConnect();
        writer.write();

        Reader reader = new Reader("text.tmp");
        reader.fileConnect();
        reader.fileRead();

        reader.fileDisconnect();
        writer.fileDisconnect();
        ftpClient.dicConnect();
    }
}
===============================================================================
//퍼싸드 적용 후 예시
package com.company.facade;

public class Ftp {
    private String host;
    private int port;
    private String path;

    public Ftp(String host, int port, String path) {
        this.host = host;
        this.port = port;
        this.path = path;
    }
    public void connect() {
        System.out.println("FTP Host: " + host + "Port : " +port+ "로 연결합니다.");
    }
    public void moveDirectory() {
        System.out.println("FTP path: " + path+"로 이동합니다.");
    }
    public void dicConnect() {
        System.out.println("FTP 연결을 종료합니다.");
    }
}

-----------------
package com.company.facade;

public class Writer { //파일쓰기
    private String fileName;
    
    public Writer(String fileName) {
        this.fileName = fileName;
    }
    
    public void fileConnect() { //파일 생성또는 이어쓰기
        String msg = String.format("Writer %s로 연결합니다.",fileName);
        System.out.println(msg);
    }
    
    public void fileDisconnect() {
        String msg = String.format("Writer %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
    
    public void write() {
        String msg = String.format("Writer %s로 파일쓰기를 합니다.",fileName);
        System.out.println(msg);
    }
}
--------------------
package com.company.facade;

public class Reader { //파일에서 읽어오기때문에 파일이름을 알아야한다.
    private String fileName;

    public Reader(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Reader %s로 연결합니다.",fileName);
        System.out.println(msg);
    }

    public void fileRead() {
        String msg = String.format("Reader %s의 내용을 읽어옵니다.",fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Reader %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
}
----------------------
package com.company.facade;

public class SftpClient {
    private Ftp ftp;
    private Reader reader;
    private Writer writer;

    public SftpClient(Ftp ftp, Reader reader, Writer writer) { //두가지방법
        this.ftp = ftp;
        this.reader = reader;
        this.writer = writer;
    }
    //오버로딩
    public SftpClient(String host, int port, String path, String fileName) {
        this.ftp = new Ftp(host,port,path);
        this.reader = new Reader(fileName);
        this.writer = new Writer(fileName);
    }

    public void connect() {
        ftp.connect();
        ftp.moveDirectory();
        writer.fileConnect();
        reader.fileConnect();
    }
    public void disConnect() {
        writer.fileDisconnect();
        reader.fileDisconnect();
        ftp.dicConnect();
    }

    public void read() {
        reader.fileRead();
    }
    public void write() {
        writer.write();
    }
}
------------------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.facade.Ftp;
import com.company.facade.Reader;
import com.company.facade.Writer;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {
        Ftp ftpClient = new Ftp("www.foo.co.kr", 22, "/home/etc");
        ftpClient.connect();
        ftpClient.moveDirectory();

        Writer writer = new Writer("text.tmp");
        writer.fileConnect();
        writer.write();

        Reader reader = new Reader("text.tmp");
        reader.fileConnect();
        reader.fileRead();

        reader.fileDisconnect();
        writer.fileDisconnect();
        ftpClient.dicConnect();
		
	   SftpClient sftpClient = new SftpClient("www.foo.co.kr", 22, "/home/etc", "text.tmp");
       sftpClient.connect();
       sftpClient.write();
       sftpClient.read();
       sftpClient.disConnect();
       //객체들의 의존을 숨기는게 퍼싸드패턴이다.
    }
}
===================================================================================
//전략패턴
유사한 행위들을 캡슐화하여, 객체의 행위를 바꾸고 싶은 경우 직접 변경하는 것이 아닌 전략만 변경하여, 유연하게 확장하는 패턴
package com.company.strategy;

public interface EncodingStrategy {
    String encode(String text);
}
------------
package com.company.strategy;

public class AppendStrategy implements EncodingStrategy{

    @Override
    public String encode(String text) {
        return "ABCD" + text; //abcd를 추가시키는
    }
}
--------------
package com.company.strategy;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class Base64Strategy implements EncodingStrategy{

    @Override
    public String encode(String text) {
        return Base64.getEncoder().encodeToString(text.getBytes()); //인코딩하기
    }
}
---------------
package com.company.strategy;

public class Encoder { //그떄그때마다 전략을 받아야한다. 어떤 인코드를 쓸지
    private EncodingStrategy encodingStrategy; //인터페이스

    public String getMessage(String message) {
        return this.encodingStrategy.encode(message);
    }

    public void setEncodingStrategy(EncodingStrategy encodingStrategy) {
        this.encodingStrategy = encodingStrategy;
    }
}
-----------------
package com.company.strategy;

public class NormalStrategy implements EncodingStrategy{
    @Override
    public String encode(String text) {
        return text;
    }
}
----------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.facade.Ftp;
import com.company.facade.Reader;
import com.company.facade.SftpClient;
import com.company.facade.Writer;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;
import com.company.strategy.*;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {


        //전략 메서드를 가진 전략객체(NormalStrategy, Base64Strategy)
        //전략 객체를 사용하는 컨텍스트(Encoder)
        //전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(main)

        Encoder encoder = new Encoder();

        //base64전략 생성
        EncodingStrategy base64 = new Base64Strategy();

        //normal전략생성
        EncodingStrategy normal = new NormalStrategy();

        String message = "hello java";
        //전략수정(원본객체는 그대로 두고)
        encoder.setEncodingStrategy(base64);
        String base64Result = encoder.getMessage(message);
        System.out.println(base64Result); //출력: aGVsbG8gamF2YQ==

        encoder.setEncodingStrategy(normal);
        String normalResult = encoder.getMessage(message);
        System.out.println(normalResult); //출력: hello java

        encoder.setEncodingStrategy(new AppendStrategy());
        String appendResult = encoder.getMessage(message);
        System.out.println(appendResult); //출력: ABCDhello java
    }
}
=========================================================================
//rest : 클라이언트<--> 서버 통신방식
- uri와 http를 이용한, 통신목적의 아키텍처 스타일(유형)
- 아키텍처 스타일이란
EX)클라이언트/서버
   저장소
   파이프/필터
   rest
   
//restful은 rest가 적용된 시스템이다.
//rest api 는 rest가 적용된 api이다.
//rest api를 제공하는 시스템은 restful이다.
rest라는 개념은 6가지 조건을 만족해야한다.
1. 일관된인터페이스
2. 클라이언트/서버(클라이언트는 서버에 요청 메시지를 전송하고 서버는 요청에 대한 응답메시지를 전송한다)
3. 비연결성(세션 등 이전상황 없이도 통신 할 수 있다)
4. 서버의 응답 메시지는 캐싱(저장 후 재사용) 될 수 있다.
5. 계층화된 시스템(계층별로 기능이 분리된다. 중간계층의 기능(로드밸런싱, 서버 증설 , 인증시스템도입등)이 변경되어도 통신에 영향을 주지 않는다.
6. 주문형 코드(option) 손쉬운 데이터 처리를 위해 서버는 클라이언트에서 실행될 스크립트를 전송할 수 있다.

-----------------
URI는 인터넷에서 특정 자원을 나타내는 주소값이다. 유일한 값이다.
요청: https://~~or.kr/resource/sample/1
URL : 특정파일이 어디에 위치하는지 식별하는 주소.
요청: https://~or.kr/ex01.pdf

URL은 URI의 하위개념이다.

URI설계원칙은
1. /를 사용해 계층관계 표현
2. 마지막에는 /를 포함하지않는다.
3. 하이픈(-)은 URI 가독성을 높이는데 사용한다.
https://~~/web-browser
4. 밑줄(_)은 사용하지 않는다
5. 소문자가 적합
6. URI에는 파일확장자를 포함하지 않는다.
7. 프로그래밍언어에 의존적인 확장자를 사용하지않는다.
https://~~/web-master.do
8. 구현에 의존적인 경로를 사용하지 않는다.
https://~~/servlet/~
9. CRUD 기능을 나타내는 것은 URI에 사용하지 않는다.
https://~~/100/READ(X)

--------------------------
HTTP는 TCP기반으로 한 REST의 특징을 모두 구현하고 있는 Web 기반의 프로토콜이다.
====================================================================
스프링부트는 톰캣을 내장하고있기 때문에 따로 설치할 필요 없다.
spring에서 불편한 설정이 없어졌다. (xml설정등)
jar로 패키징되기 떄문에 java가 깔린곳이면 어디든 jar파일을 java어플리케이션 실행가능

//Rest client 설치하기(테스트하기위해)
구글 - 웹스토어(크롬에서 동작하는 앱) 검색 - rest api client 검색 - 밑에 Talend API Tester 다운 - 확장프로그램 실행 (상단 퍼즐모양)

//만약에 톰캣 포트번호를 바꾸고 싶으면 resource - application.properties에 가서 server.port=9090 으로 수정 후 실행하면 9090으로 바뀐걸 볼수있다.
package com.example.hello.Controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController //해당 Class는 Rest API를 처리하는 Controller로 등록이된다.
@RequestMapping("/api") //RequestMapping은 URI를 지정해주는 어노테이션이다.
public class ApiController {

    @GetMapping("/hello") //http://localhost:8080/api/hello 이렇게 요청이오면 return보내라
    public String hello() {
        return "hello spring boot";
    }
}
==============================================================================
package com.example.hello.Controller;

import com.example.hello.dto.UserRequest;
import org.springframework.web.bind.ServletRequestBindingException;
import org.springframework.web.bind.annotation.*;

import java.util.Map;

@RestController
@RequestMapping("/api/get")
public class GetApiController {
    @GetMapping(path = "/hello") //http://localhost:8080/api/get/hello
    public String hello() {
        return "get Hello";
    }

    //또다른 방법(예전방식)
    //@RequestMapping("/hi") //이렇게하면 get, post, put, delete 모든 메서드가 동작하게된다.
    @RequestMapping(path = "/hi", method = RequestMethod.GET) //그래서 특정메서드로 지정 //http://localhost:8080/api/get/hi
    public String hi() {
        return "hi";
    }

    //변화하는 값을 받기 위한 pathvariable
    //http://localhost:8080/api/get/path-variable/{name}  -> 변화하는 name을 받음
    @GetMapping("/path-variable/{name}") //주소에는 소문자만 권장하니 - 으로 구분
    public String pathVariable(@PathVariable String name) {
        System.out.println("PathVariable: " +name);
        return name;
    }

    //pathVariable하면서 받는 변수에는 다른 이름으로 설정하고 싶을 때는 지정해주면된다.
    @GetMapping("/path-variable1/{name}")
    public String pathVariable1(@PathVariable(name = "name") String pathName) { //실제로 사용하는 변수는 pathName
        System.out.println("PathVariable: " +pathName);
        return pathName;
    }

    //queryParameter란
    //처음 붙을 떄는 ?로 연결하고 그 후에는 &로 연결한다.
    //search?q=intre
    //&rlz=12r3
    //http://localhost:8080/api/get/query-param?user=steve&email=steve@gmail.com&age=30
    //변수가 뭐가 들어올지 모를때
    @GetMapping("/query-param")
    public String queryParam(@RequestParam Map<String, String> queryParam) { //queryParam: size = 3

        StringBuilder sb = new StringBuilder();

        queryParam.entrySet().forEach(entry -> {
            System.out.println(entry.getKey());
            System.out.println(entry.getValue());
            System.out.println("\n");

            sb.append(entry.getKey()+"="+entry.getValue()+"\n");
        });
        return sb.toString();
    }
    //또다른 방법(명시적으로)
    @GetMapping("query-param02") //단, age에다가 String을 넣으면 에러가 난다.400에러(클라이언트 실수)
    public String queryParam02(@RequestParam String name, @RequestParam String email, @RequestParam int age) {
        System.out.println(name);
        System.out.println(email);
        System.out.println(age);

        return name + " " +email+" "+age;
    }
    
    //하지만, 변수가 이렇게 많아지면... DTO이용
    //?user=steve&email=steve@gmail.com&age=30 이렇게 요청이 오면 알아서 DTO에 매핑을 해준다.
    public String queryParam03(UserRequest userRequest) {
        System.out.println(userRequest.getName());
        System.out.println(userRequest.getEmail());
        System.out.println(userRequest.getAge());

        return userRequest.toString();
    }
    
}
---------------
package com.example.hello.dto;

public class UserRequest {
    private String name;
    private String email;
    private int age;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "UserRequest{" +
                "name='" + name + '\'' +
                ", email='" + email + '\'' +
                ", age=" + age +
                '}';
    }
}
==================================================================================
//JSON구조
string : value,
number : value,
boolean : value,
object: value,
array : value []
{
	"key" : "value"
}

// '_' 이거를 스네이크케이스라고한다. phone_number

{
	"phone_number" : "value",
	"phoneNumber" : "010-1111-1111",
	"age": 10,
	"isAgree": false,
	"account" : {
		"email": "steve@email.com",
		"password": "1234",
	}
}

//user 조회하는 경우
{
	"account": "abcd",
	"password": "1234",
}

//배열은 같은 값의 반복이다.
{
	"user_list": [
		{
			"account": "abcd",
			"password": "1234",
		},
		{
			"account": "aaaa",
			"password" : "1111",
		}
	]
}

=============================================================================
package com.example.post.dto;

public class PostRequestDto {
    private String account;
    private String email;
    private String address;
    private String password;
    //기본은 카멜케이스이다. 
    private String phoneNumber; //phone_number
    //크롬에서 Talend로 테스트할 때 body에 "phone_number" : "010-1111-1111" 이렇게 해서 보내면 폰넘버에서 null이 뜬다.
    //그러면 매핑할려면?? 일일이 변수에다가 해야하는 귀찮음이 있긴하지만
    //실제로 들어오는 이름값을 매핑시켜준다. "phone_number" : "010-1111-1111" -> phoneNumber로 매핑시켜줌
    //@JsonProperty("phone_number") phone_number로 오면 phoneNumber로 매핑해줘라
    //private String phoneNumber;

    //@JsonProperty("OTP") 스네이크케이스, 카멜케이스도 아닌경우에는 이렇게
    //private String OTP;

    public String getAccount() {
        return account;
    }

    public void setAccount(String account) {
        this.account = account;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    @Override
    public String toString() {
        return "PostRequestDto{" +
                "account='" + account + '\'' +
                ", email='" + email + '\'' +
                ", address='" + address + '\'' +
                ", password='" + password + '\'' +
                ", phoneNumber='" + phoneNumber + '\'' +
                '}';
    }
}
--------------------
package com.example.post.controller;

import com.example.post.dto.PostRequestDto;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.Map;

@RestController
@RequestMapping("/api")
public class PostApiController {
    @PostMapping("/post")
    public void post(@RequestBody Map<String, Object> requestData) {
        requestData.entrySet().forEach(soentry -> {
            System.out.println(("key: " +soentry.getKey()));
            System.out.println(("value: " +soentry.getValue()));
        });
    }

    @PostMapping("/post1")
    public void post1(@RequestBody PostRequestDto requestData) {
       System.out.println(requestData);
    }
}
=========================================================================================
//put은 멱등성인데 첨에 데이터가 없으면 생성하고 있으면 업데이트를 한다.
//안정성은 가지고있지않다. 왜냐하면 안정하지않은 데이터가 들어가도 업데이트 하기 떄문에.
package com.example.put.dto;


import com.fasterxml.jackson.annotation.JsonProperty;

public class CarDto {
    private String name;
    @JsonProperty("car_number")
    private String carNumber;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCarNumber() {
        return carNumber;
    }

    public void setCarNumber(String carNumber) {
        this.carNumber = carNumber;
    }

    @Override
    public String toString() {
        return "CarDto{" +
                "name='" + name + '\'' +
                ", carNumber='" + carNumber + '\'' +
                '}';
    }
}
-----------------
package com.example.put.dto;

import com.fasterxml.jackson.databind.PropertyNamingStrategy;
import com.fasterxml.jackson.databind.annotation.JsonNaming;

import java.util.List;

@JsonNaming(value = PropertyNamingStrategy.SnakeCaseStrategy.class)
public class PostRequestDto {
    private String name;
    private int age;
    private List<CarDto> carList;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public List<CarDto> getCarList() {
        return carList;
    }

    public void setCarList(List<CarDto> carList) {
        this.carList = carList;
    }

    @Override
    public String toString() {
        return "PostRequestDto{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", carList=" + carList +
                '}';
    }
}
--------------------
package com.example.put;

import com.example.put.dto.PostRequestDto;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class PutApiController {
    @PutMapping("/put")
    public PostRequestDto put(@RequestBody PostRequestDto requestDto) {
        //Json 디자인
//        {
//            "name" : "steve",
//            "age" : 10,
//            "car_list" : [
//                {
//                    "name" : "BMW",
//                    "car_number" : "11가 1234"
//                },
//                {
//                    "name" : "Audi",
//                    "car_number" : "11가 2222"
//                }
//            ]
//        }
        System.out.println(requestDto); //크롬에서 put으로 해서 http://localhost:8080/api/put, body에 json디자인한걸 넣으면
        //하지만 carList=null이라고 뜬다. 왜냐하면 dto에는 catList로 했지만 body에는 car_list로 스네이크케이스로 했기떄문에
        //클래스에 대해 전체적으로 같은 룰을 적용시킬때는 (물론, jsonproperty해도 되지만) @JsonNaming을 쓴다.(PostRequestDto, CarDto)

        return requestDto; //받은 json body를 그대로 넘겨준다.
        //즉, "name" :requestDto.getName() 이렇게 할필요없이 스프링부트에서는 dto에 매핑해서 json형태로 response해준다.

        //PathVariable 테스트
//        @PutMapping("/put/{userId}")
//        public PostRequestDto put(@RequestBody PostRequestDto requestDto, @PathVariable Long userId) {
//            System.out.println(userId);
//            http://localhost:8080/api/put/100, body에 json넣고 send하면 콘솔에 찍힌다.
//        }
    }
}
==================================================================================================
//delete메서드 멱등하다.(데이터가 없어도 ok를 리턴(200) 에러안띄운다) 안정성은 가지고있지 않다. 보통 인덱스, 또는 유니크한값을 기준으로 지운다.
//http://localhost:8080/api/delete/100?account=user01

package com.example.delete.controller;

import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class DeleteApiController {
    @DeleteMapping("/delete/{userId}")
    public void delete(@PathVariable String userId, @RequestParam String account) {
        System.out.println(userId);
        System.out.println(account);
    }
}
=================================================================================================
//Response 내려주기
package com.example.response.dto;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;

//일괄적으로 스네이크케이스 적용 시 @JsonNaming(value=PropertyNamingStrategy.SnakeCaseStrategy.class)
//response로 응답을 줄 때 phone_number로 주게된다.
//단, 보낼 때도 json body에 phone_number로 보내줘야한다.
// { phone_number : "010-1111-1111" } 이렇게
@JsonInclude(JsonInclude.Include.NON_NULL)
public class User {
    private String name;
    private int age; //이렇게 primitive타입의 int는 값이 없으면 0 , wrapper클래스인 Integer로 하면 null이 된다. -> null값을 JSON으로 넘기고 싶지않을 때
    //@JsonInclude를 쓴다. user.setName("steve");
    //        user.setAddress("패스트 캠퍼스"); 이렇게 age에 값이 없으면 null이지만 response할 때 null값은 제외시키는게 @JsonInclude이다.
//    {
//        "name" : "steve",
//        "address": "패스트 캠퍼스"
//    } //이렇게 null값은 제외시키고 있는값만 json으로 response한다
    private String phoneNumber;
    private String address;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", phoneNumber='" + phoneNumber + '\'' +
                ", address='" + address + '\'' +
                '}';
    }
}
---------------------
package com.example.response.controller;

import com.example.response.dto.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class ApiController {
    @GetMapping("/text")
    public String text(@RequestParam String account) {
        return account; //일반 String으로 response
    }

    //Json으로 response
    @PostMapping("/json")
    public User json(@RequestBody User user) {
        //Json body
//        {
//            "name":"steve",
//                "age": 10,
//                "phoneNumber" : "010-1111-2222",
//                "address" : "패스트캠퍼스"
//        }
        return user; //json으로 위에 처럼 응답을 준다.
        //request가 오게되면 -> object mapper로 인해서 -> object로 바뀌고 -> postmapping -> object로 받고 -> object mapper -> json -> response
    }

    //특정 reponse로 내려주기
    //put 으로 resource가 생성됐을 때 201 response 할것이다.
    //수정됐을 떄는 200
    @PutMapping("/put")
    public ResponseEntity<User> put(@RequestBody User user) { //ResponseEntitiy를 통해 header값도 추가가능, 응답에 대해 커스텀마이징도 가능
        return ResponseEntity.status(HttpStatus.CREATED).body(user); //마찬가지로 json으로 매핑되서 response된다.
    }
    //크롬에 put , http://localhost:8080/api/put 하고 body에 위에 json body를 넣으면 201로 response가 뜬다.


}
-------------------
package com.example.response.controller;

import com.example.response.dto.User;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller //애는 html같은 리소스를 찾는다. @RestController는 API를 만들 때 , @Controller는 페이지를 리턴할 때
//그렇다면 @Controller에서는 json을 어떻게 보냄?? -> ResponseBody
public class PageController {
    @RequestMapping("/main")
    //@Controller라는 어노테이션은 String을 return하게되면 리소스를 찾지만 @ResponseBody를 붙이면 말그대로 body를 만들어서 response하겠다라는 의미이다.
    public String main() {
        return "main.html"; //http://localhost:8080/main
    }

    @ResponseBody
    @GetMapping("/user")
    public User user() {
        //기존
        //User user = new User();

        //자바 11에서의 타입추론
        var user = new User();
        user.setName("steve");
        user.setAddress("패스트 캠퍼스");
        return user; //json으로 응답
        // http://localhost:8080/user
    }

}
------------------
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
Main html입니다.
</body>
</html>
==================================================================================================
#)object-mapper 동작 방식
package com.example.objectmapper;

import com.fasterxml.jackson.annotation.JsonProperty;

public class User {
    private String name;
    private int age;
    @JsonProperty("phone_number")
    private String phoneNumber;

    public User() {}

    public User(String name, int age, String phoneNumber) {
        this.name = name;
        this.age = age;
        this.phoneNumber = phoneNumber;
    }

    public String getName() {
        return name;
    }

    public int getAge() {
        return age;
    }
    //만약에 내가만든 클래스가 objectmapper가 활용하는 클래스이면 get이라는 이름을 붙이는 것은 좋지않다.
//    public User getDefaultUser() {
//        return new User("default",0);
//    }


    public String getPhoneNumber() {
        return phoneNumber;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", phoneNumber='" + phoneNumber + '\'' +
                '}';
    }
}
---------------
경로: test/java
package com.example.objectmapper;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.junit.jupiter.api.Test;
import org.springframework.boot.test.context.SpringBootTest;

@SpringBootTest
class ObjectMapperApplicationTests {

    @Test
    void contextLoads() throws JsonProcessingException {
        System.out.println("hello");

        //오브젝트 매퍼는
        //Text형태의 Json을 -> Object
        //Object -> Text Json

        //controller request로 json(text)이 오면 -> object
        //response에서 object -> json(text)

        var objectMapper = new ObjectMapper();

        //object를 text로 바꿔보자
        var user = new User("steve", 10, "010-1111-1111");
        var text = objectMapper.writeValueAsString(user);//예외처리도 해주기
        System.out.println(text);
        //여기까지 하면 에러가나는데 ObjectMapper는 getter를 참조한다. 따라서 getter를 만들어줘야한다.(User)
        //즉, object -> text로 바뀔 떄는 Object mapper가 getter method를 참조한다.
        //출력: {"name":"steve","age":10,"phone_number":"010-1111-1111"} 알아서 snake case로 변환


        //text->object로 바꿔보자
        var objectUser = objectMapper.readValue(text, User.class);//text에는 json형태의 text, User라는 클래스로 바꾼다
        System.out.println(objectUser);
        //이렇게 하면 에러가난다.
        //text->object로 할때는 디폴트생성자가 있어야한다(User)
        //출력: User{name='steve', age=10, phoneNumber='010-1111-1111'}
    }

}
=========================================================================
스프링은 여러가지 모듈이 있지만 그 중에서 스프링부트, 스프링클라우드, 스프링데이터, 스프링시큐리티에 중점
스프링의 등장은 2000년대 초의 자바 EE애플리케이션은 작성/테스트가 매우 어려웠으며, 한번테스트하기가 번거러웠다.
이로인해, 느슨한결합이 된 애플리케이션 개발이 힘든상태였으며, 특히 데이터베이스와 같이 외부에 의존성을 두는 경우 단위테스트가 불가능했다.

IoC(inversion of Control) 제어의 역전
- 스프링에서는 일반적으로 java객체를 new로 생성하여 개발자가 관리하는 것이아닌 spring Container에 모두 맡긴다.
예를들어, 프린터라는 싱글톤객체를 이용하면 프린터라는 객체를 만든 후에 가져다 쓰는데 그러한 형태가 스프링에서는 없다
스프링컨테이너라고 하는 공간에 생성하고자하는 객체가 이미 만들어져서 들어가있고 싱글톤의 형태로 관리가 된다.
즉, 개발자가 객체를 관리하는 것이아니라 프레임워크한테 제어의 권한을 넘긴다. 즉, 모든 객체의 관리를 스프링컨테이너에서 관리한다. -> 제어의 역전(권한이 넘어갔음)

DI(Dependency Injection)
그럼 만들어진 객체를 어떻게 쓸까? -> DI
- 외부로 부터 내가 사용할 객체를 주입을 받는다.
- 주입을 해주는 애는 스프링컨테이너이다.
그럼 DI를 왜쓰는가?
1. 특정객체가 다른객체에 의존하고있는데 그런 부분을 코드로부터 격리시킨다. 코드테스트가 용이하다. 해당객체가 없어도 테스트 가능
2. DI를 통하여, 불가능한 상황을 Mock와 같은 기술을 통하여, 안정적으로 테스트 가능하다.
3. 코드를 확장하거나 변경할 때 영향을 최소화한다. 내가 쓰고자하는 객체는 주입을 받기 때문에 내코드가 변경되더라도 영향을 받지않는다.(추상화를 통해서)
4. 순환첨조를 막을 수 있다.(내가 나를 참조한다던지, 내가 참조했는데 그 객체가 나를 참조하는 형태)

===========================================================================
//기존 코드 방식
package com.company.ioc;

public class Main {

    public static void main(String[] args) {
	    String url = "www.naver.com/books/it?page=10&size=20&name=spring-boot"; //인코딩할 url
        //base64로 인코딩해주세요
        Encoder encoder = new Encoder();
        String result = encoder.encode(url);
        System.out.println(result); //d3d3Lm5hdmVyLmNvbS9ib29rcy9pdD9wYWdlPTEwJnNpemU9MjAmbmFtZT1zcHJpbmctYm9vdA==
		
		//또 url 인코딩해주세요
        //그러면 또 urlencoder만들어야겠네?
        UrlEncoder urlEncoder = new UrlEncoder();
        String urlResult = urlEncoder.encode(url);
        System.out.println(urlResult); //www.naver.com%2Fbooks%2Fit%3Fpage%3D10%26size%3D20%26name%3Dspring-boot
		
		//이렇게 계속 만들것인가?? -> 인터페이스, di이용
    }
}
----------------
package com.company.ioc;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public class UrlEncoder {
    public String encode(String message) {
        try {
            return URLEncoder.encode(message, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return null; //예외가 났을 떄는 null리턴
        }
    }
}
---------------------
package com.company.ioc;

import java.util.Base64;

public class Encoder {
    public String encode(String message) {
        return Base64.getEncoder().encodeToString(message.getBytes());
    }
}
===============================================================================
//인터페이스로 
package com.company.ioc;

public class Main {

    public static void main(String[] args) {
	    String url = "www.naver.com/books/it?page=10&size=20&name=spring-boot"; //인코딩할 url

        //이렇게 해도 코드 변화가 크게없네? 만들떄마다 이렇게 해야돼?? -> 안에다 감추자 Encoder에 (지금은 적용안됌)
        IEncoder encoder = new Base64Encoder();
        String result = encoder.encode(url);

        IEncoder urlEncoder = new UrlEncoder();
        String urlResult = urlEncoder.encode(url);

        System.out.println(urlResult);

    }
}
------------------
package com.company.ioc;

public interface IEncoder {
    String encode(String message);
}
------------------
package com.company.ioc;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public class UrlEncoder implements IEncoder{
    public String encode(String message) {
        try {
            return URLEncoder.encode(message, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return null; //예외가 났을 떄는 null리턴
        }
    }
}
-----------------------
package com.company.ioc;

import java.util.Base64;

public class Base64Encoder implements IEncoder{
    public String encode(String message) {
        return Base64.getEncoder().encodeToString(message.getBytes());
    }
}
=============================================================================================
//Encoder에 감추자 -> 코드는 줄어듬
package com.company.ioc;

public class Main {

    public static void main(String[] args) {
	    String url = "www.naver.com/books/it?page=10&size=20&name=spring-boot"; //인코딩할 url

       Encoder encoder = new Encoder(); //이렇게 코드는 줄어들었지만 base64, urlEncoding할때마다 Encoder클래스를 건드려야한다. -> 비효율적
       String result = encoder.encode(url);

        System.out.println(result);

    }
}
------------------
package com.company.ioc;

public interface IEncoder {
    String encode(String message);
}
--------------------
package com.company.ioc;

import java.util.Base64;

public class Base64Encoder implements IEncoder{
    public String encode(String message) {
        return Base64.getEncoder().encodeToString(message.getBytes());
    }
}
---------------------
package com.company.ioc;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public class UrlEncoder implements IEncoder{
    public String encode(String message) {
        try {
            return URLEncoder.encode(message, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return null; //예외가 났을 떄는 null리턴
        }
    }
}
--------------------------
package com.company.ioc;

import java.util.Base64;

public class Encoder {
    private IEncoder iEncoder;

    public Encoder() {
        this.iEncoder = new Base64Encoder();
        //this.iEncoder = new UrlEncoder();
    }

    public String encode(String message)
    {
        return iEncoder.encode(message);
    }
}
====================================================================
//DI 이용
package com.company.ioc;

public class Main {

    public static void main(String[] args) {
	    String url = "www.naver.com/books/it?page=10&size=20&name=spring-boot"; //인코딩할 url

        //주입객체만 바꾼다.
        //Encoder를 건드릴 필요는 없다.
        Encoder encoder = new Encoder(new Base64Encoder()); //DI이지만 내가 직접 객체를 만들고 있다. 그래서 다음장에 IoC를 이용한다.
        //Encoder encoder = new Encoder(new UrlEncoder());
        String result = encoder.encode(url);
        System.out.println(result);

    }
}
-----------------
package com.company.ioc;

public interface IEncoder {
    String encode(String message);
}
-------------------
package com.company.ioc;

import java.util.Base64;

public class Base64Encoder implements IEncoder{
    public String encode(String message) {
        return Base64.getEncoder().encodeToString(message.getBytes());
    }
}
-------------------
package com.company.ioc;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

public class UrlEncoder implements IEncoder{
    public String encode(String message) {
        try {
            return URLEncoder.encode(message, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return null; //예외가 났을 떄는 null리턴
        }
    }
}
---------------------
package com.company.ioc;

import java.util.Base64;

public class Encoder {
    private IEncoder iEncoder;
    
    //외부에서 iEncoder를 주입받음
    public Encoder(IEncoder iEncoder) { //new Base64Encoder()
//        this.iEncoder = new Base64Encoder();
//        this.iEncoder = new UrlEncoder();
        this.iEncoder = iEncoder;
    }

    public String encode(String message)
    {
        return iEncoder.encode(message);
    }
}
=======================================================================
//이제 IoC개념을 보자 -> new할필요없다.
package com.example.springioc;

public interface IEncoder {
    String encode(String message);
}
-----------------
package com.example.springioc;

import org.springframework.stereotype.Component;

import java.util.Base64;

@Component //Base64Encoder가 빈으로 등록된다.(스프링이 관리한다)
public class Base64Encoder implements IEncoder{
    public String encode(String message) {
        return Base64.getEncoder().encodeToString(message.getBytes());
    }
}
--------------------
package com.example.springioc;

import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

@Component
public class UrlEncoder implements IEncoder{
    public String encode(String message) {
        try {
            return URLEncoder.encode(message, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return null; //예외가 났을 떄는 null리턴
        }
    }
}
------------------------
package com.example.springioc;

import java.util.Base64;

public class Encoder {
    private IEncoder iEncoder;
    
    //외부에서 iEncoder를 주입받음
    public Encoder(IEncoder iEncoder) { //new Base64Encoder()
//        this.iEncoder = new Base64Encoder();
//        this.iEncoder = new UrlEncoder();
        this.iEncoder = iEncoder;
    }

    //bean을 주입받을수있는 장소가 변수,생성자, setter가 있다.
    public void setIEncoder(IEncoder iEncoder) {
        this.iEncoder =iEncoder;
    }

    public String encode(String message)
    {
        return iEncoder.encode(message);
    }
}
----------------------------
package com.example.springioc;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component //얘도 스프링에서 빈으로 등록해서 관리해줘
public class ApplicationContextProvider implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    //여기도 보면 applicationContext 라는 객체를 외부로부터 주입을 받는다.(스프링이알아서)
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }

    public static ApplicationContext getContext() {
        return context;
    }
}
--------------------------------
package com.example.springioc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

@SpringBootApplication //옆에 돋보기를 누르면 빈에 등록된 객체를 볼수있다.
public class SpringIoCApplication {

    public static void main(String[] args) {
        String url = "www.naver.com/books/it?page=10&size=20&name=spring-boot";
        SpringApplication.run(SpringIoCApplication.class, args);

        //위에 SpringAppliction이 실행되고 나면
        ApplicationContext context = ApplicationContextProvider.getContext();

        //주입을 위해 (객체를 받음)
        Base64Encoder base64Encoder = context.getBean(Base64Encoder.class);
        UrlEncoder urlEncoder = context.getBean(UrlEncoder.class);
        Encoder encoder = new Encoder(base64Encoder);

        String result = encoder.encode(url); //base64Encoder
        System.out.println(result);

        //setter로 urlEncoder로 다시 주입
        encoder.setIEncoder(urlEncoder);
        result =encoder.encode(url);
        System.out.println(result);
    }

}
========================================================================
//Encoder도 빈으로 등록해보자
package com.example.springioc;

public interface IEncoder {
    String encode(String message);
}
---------------
package com.example.springioc;

import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;

@Component
public class UrlEncoder implements IEncoder{
    public String encode(String message) {
        try {
            return URLEncoder.encode(message, "UTF-8");
        } catch (UnsupportedEncodingException e) {
            e.printStackTrace();
            return null; //예외가 났을 떄는 null리턴
        }
    }
}
--------------------
package com.example.springioc;

import org.springframework.stereotype.Component;

import java.util.Base64;

@Component //Base64Encoder가 빈으로 등록된다.(스프링이 관리한다)
//@Component("base74Encoder") 나는 이 이름으로 쓰겠다. @Qualifier("base74Encoder") 로 가능
public class Base64Encoder implements IEncoder{
    public String encode(String message) {
        return Base64.getEncoder().encodeToString(message.getBytes());
    }
}
----------------------
package com.example.springioc;

import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

import java.util.Base64;

@Component //에러가뜨는데 빈에서 스프링이 선택할 때 하나만있으면 매칭되는데 지금은 우리가 base64, urlEncoder를 컴포넌트로 등록했기떄문에
//@Qualifier로 지정해줘야된다.
public class Encoder {
    private IEncoder iEncoder;
    
    //외부에서 iEncoder를 주입받음(클래스의 앞글자는 소문자)
    public Encoder(@Qualifier("urlEncoder") IEncoder iEncoder) { //new Base64Encoder()
//        this.iEncoder = new Base64Encoder();
//        this.iEncoder = new UrlEncoder();
        this.iEncoder = iEncoder;
    }

    //bean을 주입받을수있는 장소가 변수,생성자, setter가 있다.
    public void setIEncoder(IEncoder iEncoder) {
        this.iEncoder =iEncoder;
    }

    public String encode(String message)
    {
        return iEncoder.encode(message);
    }
}
-----------------------
package com.example.springioc;

import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.stereotype.Component;

@Component //얘도 스프링에서 빈으로 등록해서 관리해줘
public class ApplicationContextProvider implements ApplicationContextAware {

    private static ApplicationContext context;

    @Override
    //여기도 보면 applicationContext 라는 객체를 외부로부터 주입을 받는다.(스프링이알아서)
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        context = applicationContext;
    }

    public static ApplicationContext getContext() {
        return context;
    }
}
----------------------
package com.example.springioc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;

@SpringBootApplication //옆에 돋보기를 누르면 객체를 볼수있다.(스프링 컨테이너에서 관리되는 객체를 빈이라고 부른다)
public class SpringIoCApplication {

    public static void main(String[] args) {
        String url = "www.naver.com/books/it?page=10&size=20&name=spring-boot";
        SpringApplication.run(SpringIoCApplication.class, args);

        //위에 SpringAppliction이 실행되고 나면
        ApplicationContext context = ApplicationContextProvider.getContext();

        //주입을 위해 (객체를 받음)
        //Base64Encoder base64Encoder = context.getBean(Base64Encoder.class);
        //UrlEncoder urlEncoder = context.getBean(UrlEncoder.class);
        Encoder encoder = context.getBean(Encoder.class);

        String result = encoder.encode(url); //Encoder에서 내가 @Qualifier("urlEncoder")로 했으니 url인코딩으로 된다.
        System.out.println(result);

    }

}
====================================================================
//직접 빈으로 등록해보자
package com.example.springioc;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@SpringBootApplication //옆에 돋보기를 누르면 객체를 볼수있다.(스프링 컨테이너에서 관리되는 객체를 빈이라고 부른다)
public class SpringIoCApplication {

    public static void main(String[] args) {
        String url = "www.naver.com/books/it?page=10&size=20&name=spring-boot";
        SpringApplication.run(SpringIoCApplication.class, args);

        //위에 SpringAppliction이 실행되고 나면
        ApplicationContext context = ApplicationContextProvider.getContext();

        //주입을 위해 (객체를 받음)
        //Base64Encoder base64Encoder = context.getBean(Base64Encoder.class);
        //UrlEncoder urlEncoder = context.getBean(UrlEncoder.class);
        Encoder encoder = context.getBean("base74Encoder", Encoder.class); //base64가 2개겹치니까(@Bean부분과) 명시적으로

        String result = encoder.encode(url); //Encoder에서 내가 @Qualifier("urlEncoder")로 했으니 url인코딩으로 된다.
        System.out.println(result);

    }

}

//직접 빈을 등록해보자
@Configuration //한개~여러개 빈을 등록할 것이다.
class AppConfig {

    //여기서 문제가 encoder라는 이름이 중복이된다. 그래서 @Bean("base74Encoder")라고 명시 -> 빈에 이미 base64Encoder가 있으니 74로
    @Bean("base74Encoder")
    public Encoder encoder(Base64Encoder base64Encoder) { //스프링으로 부터 주입받고
        return new Encoder(base64Encoder);
    }
    @Bean("urlEncode") //여기도 빈에 이미 urlEncoder가 있어서 urlEncode로 이름 설정
    public Encoder encoder(UrlEncoder urlEncoder) {
        return new Encoder(urlEncoder);
    }
}

================================================================================================================
//AOP(Aspect Oriented Programming) 관점지향 프로그램
스프링어플리케이션은 대부분 특별한 경우를 제외하고는 MVC 웹어플리케이션에서는 Web Layer, Business Layer, Data Layer로 정의

- web layer : RestAPI를 제공하며, client 중심의 로직 적용
- Business layer : 내부 정책에 따른 logic를 개발하며, 주로 해당 부분을 개발
- Data layer : 데이터베이스 및 외부와의 연동을 처리

@Aspect : 자바에서 널리 사용하는 AOP프레임워크에 포함, AOP를 정의하고싶은 클래스에 할당
@Pointcut : AOP를 적용시킬 지점을 설정.
@Before : 메소드 실행하기 이전
@After : 메소드가 성공적으로 실행 후, 예외가 발생되더라도 실행
@AfterReturing : 메서드 호출 성공 실행 시
@AfterThrowing : 메서드 호출 실패 예외 발생
@Around : before/after 모두제어
=================================================================
//build.gradle
plugins {
    id 'org.springframework.boot' version '2.6.6'
    id 'io.spring.dependency-management' version '1.0.11.RELEASE'
    id 'java'
}

group = 'com.example'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '11'

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-aop' //추가
    implementation 'org.springframework.boot:spring-boot-starter-web'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') {
    useJUnitPlatform()
}



----------------
package com.example.aop.dto;

public class User {
    private String id;
    private String pw;
    private String email;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPw() {
        return pw;
    }

    public void setPw(String pw) {
        this.pw = pw;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", pw='" + pw + '\'' +
                ", email='" + email + '\'' +
                '}';
    }
}
----------------
package com.example.aop.controller;

import com.example.aop.dto.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class RestApiController {
    @GetMapping("/get/{id}")
    public void get(@PathVariable Long id, @RequestParam String name) {
        System.out.println("get mehotd: " + id);
        System.out.println("get mehotd: " + name);
    }

    @PostMapping("/post")
    public void post(@RequestBody User user) { //크롬에 body에 넣어서
        //http://localhost:8080/api/post
//        {
//            "id" : "steve",
//            "pw" : "1234",
//            "email": "steve@gmail.com"
//        }
        System.out.println("post method: " + user);
    }
}
===============================================================================
//위에 처럼 간단한경우는 저렇게 해도되지만 많아지면 일일이 system.out.println해서 다 찍어야하나??

#)먼저 post 요청 시
//http://localhost:8080/api/post
//        {
//            "id" : "steve",
//            "pw" : "1234",
//            "email": "steve@gmail.com"
//        }

package com.example.aop.dto;

public class User {
    private String id;
    private String pw;
    private String email;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPw() {
        return pw;
    }

    public void setPw(String pw) {
        this.pw = pw;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", pw='" + pw + '\'' +
                ", email='" + email + '\'' +
                '}';
    }
}
-----------------
package com.example.aop.controller;

import com.example.aop.dto.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class RestApiController {
    @GetMapping("/get/{id}")
    public String get(@PathVariable Long id, @RequestParam String name) {
        System.out.println("get mehotd: " + id);
        System.out.println("get mehotd: " + name);
        return id + " " + name;
    }

    @PostMapping("/post")
    public User post(@RequestBody User user) { //크롬에 body에 넣어서
        //http://localhost:8080/api/post
//        {
//            "id" : "steve",
//            "pw" : "1234",
//            "email": "steve@gmail.com"
//        }
        System.out.println("post method: " + user); //3.  User{id='steve', pw='1234', email='steve@gmail.com'}
        return user; //afterReturning으로
    }
}
--------------------
package com.example.aop.aop;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Aspect //aop로 동작
@Component //스프링에서 관리
public class ParameterAop {
    //controller하위 메서드가 실행되기전에 before부분이 실행될거고 그 후에 controller 메서드 실행 후 정상리턴되면 afterReturning에서 해당 object를 볼수가있다.
    @Pointcut("execution(* com.example.aop.controller..*.*(..))") //어디에 적용시킬건지(controller패키지밑에 모든 메서드를 aop로 보겠다)
    private void cut() {}

    @Before("cut()") //cut이 실행되는 지점에 before메서드를 실핼
    public void before(JoinPoint joinPoint) {
        Object[] args = joinPoint.getArgs();
        //크롬에서 body에 넣어서 보내게 되면
        for(Object obj : args) {
            System.out.println("type: " + obj.getClass().getSimpleName()); //1(출력순서). type: User
            System.out.println("value: " + obj); //2. User{id='steve', pw='1234', email='steve@gmail.com'}
            //그 후에 RestApiController로 가서 post실행
        }
    }

    @AfterReturning(value = "cut()", returning = "returnObj")
    public void afterReturn(JoinPoint joinPoint, Object returnObj) {
        System.out.println("return obj:" + returnObj); //4. User{id='steve', pw='1234', email='steve@gmail.com'}
    }
}
=====================================================================
#)get 요청시 
http://localhost:8080/api/get/100?name=steve 로 요청
package com.example.aop.dto;

public class User {
    private String id;
    private String pw;
    private String email;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPw() {
        return pw;
    }

    public void setPw(String pw) {
        this.pw = pw;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", pw='" + pw + '\'' +
                ", email='" + email + '\'' +
                '}';
    }
}
-----------------
package com.example.aop.controller;

import com.example.aop.dto.User;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class RestApiController {
    @GetMapping("/get/{id}")
    public String get(@PathVariable Long id, @RequestParam String name) {
		
		
        System.out.println("get mehotd: " + id);  // 6. get method: 100
        System.out.println("get mehotd: " + name); // 7. get method: steve
        return id + " " + name; //afterReturing으로
    }

    @PostMapping("/post")
    public User post(@RequestBody User user) { 
        System.out.println("post method: " + user); 
        return user;
    }
}
--------------------
package com.example.aop.aop;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

@Aspect //aop로 동작
@Component //스프링에서 관리
public class ParameterAop {
    //controller하위 메서드가 실행되기전(파라미터까지는 받고 아래 내용이 실행 전이다)에 before부분이 실행될거고 그 후에 controller 메서드 실행 후 정상리턴되면 afterReturning에서 해당 object를 볼수가있다.
    @Pointcut("execution(* com.example.aop.controller..*.*(..))") //어디에 적용시킬건지(controller패키지밑에 모든 메서드를 aop로 보겠다)
    private void cut() {}

    @Before("cut()") //cut이 실행되는 지점에 before메서드를 실핼
    public void before(JoinPoint joinPoint) {
		//메서드 이름출력
		MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        Method method = methodSignature.getMethod();
        System.out.println(method.getName()); //1. get 
		
        Object[] args = joinPoint.getArgs();
        //크롬에서 body에 넣어서 보내게 되면
        for(Object obj : args) {
            System.out.println("type: " + obj.getClass().getSimpleName()); //2(출력순서). type: Long  4. type: String 
            System.out.println("value: " + obj); //3. value: 100   5. value: steve
            //그 후에 RestApiController로 가서 get실행
        }
    }

    @AfterReturning(value = "cut()", returning = "returnObj")
    public void afterReturn(JoinPoint joinPoint, Object returnObj) {
        System.out.println("return obj:" + returnObj); //8. return obj: 100 steve
    }
}
==========================================================================================================
//aop의 또 다른 기능은 메서드의 실행시간을 가지고 서버의 부하, 서버의 상태를 로깅으로 남길수있다.
package com.example.aop.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME) //런타임때 사용
public @interface Timer {

}
---------------
package com.example.aop.aop;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Aspect //aop로 동작
@Component //스프링에서 관리
public class ParameterAop {
    //controller하위 메서드가 실행되기전에 before부분이 실행될거고 그 후에 controller 메서드 실행 후 정상리턴되면 afterReturning에서 해당 object를 볼수가있다.
    @Pointcut("execution(* com.example.aop.controller..*.*(..))") //어디에 적용시킬건지(controller패키지밑에 모든 메서드를 aop로 보겠다)
    private void cut() {}

    @Before("cut()") //cut이 실행되는 지점에 before메서드를 실핼
    public void before(JoinPoint joinPoint) {
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        Method method = methodSignature.getMethod();
        System.out.println("여기니? :" + method.getName());

        //deletemapping은 여기 실행안됌. 받은 인자가 없어서 -> @AfterReturning으로
        Object[] args = joinPoint.getArgs();
        for(Object obj : args) {
            System.out.println("여기는 실행안되네??");
            System.out.println("type: " + obj.getClass().getSimpleName());
            System.out.println("value: " + obj);

        }
    }

    @AfterReturning(value = "cut()", returning = "returnObj")
    public void afterReturn(JoinPoint joinPoint, Object returnObj) {
        System.out.println("return obj:" + returnObj); //return obj: null (void라서)
    }
}
-----------------
package com.example.aop.aop;

import org.aspectj.lang.ProceedingJoinPoint;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;
import org.springframework.util.StopWatch;

@Aspect
@Component //@Component는 클래스단위로, @Bean은 클래스에 붙일 수 없다. @Bean은 메서드에서 사용
public class TimerAop {
    @Pointcut("execution(* com.example.aop.controller..*.*(..))") //모든메서드이지만 delete로 요청이 왔기때문에 delete 함수실행전 -> before로 이동
    private void cut() {}

    @Pointcut("@annotation(com.example.aop.annotation.Timer)") //어노테이션이 @Timer로 설정된 메서드만 로깅을 할거야. 근데 시간을 잴거기 때문에
    //전,후메서드가 필요한데 before,after로 timer를 공유할수없다. 이래서 @Around
    private void enableTimer() {}

    @Around("cut() && enableTimer()")
    public void around(ProceedingJoinPoint joinPoint) throws Throwable {

        StopWatch stopWatch = new StopWatch();
        stopWatch.start();

        System.out.println("전");
        Object result = joinPoint.proceed(); //이 메서드의 실행 전 후로 나눈다.(위 아래) -> deletemapping에 있는 타이머 실행
        System.out.println("후");
        
        stopWatch.stop();
        System.out.println("total time: " + stopWatch.getTotalTimeSeconds()); //총 얼마나 걸렸는지 //이렇게 aop를 통해서 시간다 찍어서 모니터링가능
    }
}
------------------
package com.example.aop.controller;

import com.example.aop.annotation.Timer;
import com.example.aop.dto.User;
import org.springframework.util.StopWatch;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class RestApiController {
    @GetMapping("/get/{id}")
    public String get(@PathVariable Long id, @RequestParam String name) {
//        StopWatch stopWatch = new StopWatch();
//        stopWatch.start();
//        //Logic이 들어가는 곳
//        stopWatch.stop();
//        System.out.println("total time: " + stopWatch.getTotalTimeSeconds()); //총 얼마나 걸렸는지
        return id + " " + name;
    }

    @PostMapping("/post")
    public User post(@RequestBody User user) { //크롬에 body에 넣어서
        //http://localhost:8080/api/post
//        {
//            "id" : "steve",
//            "pw" : "1234",
//            "email": "steve@gmail.com"
//        }
//        StopWatch stopWatch = new StopWatch();
//        stopWatch.start();
//        //Logic이 들어가는 곳.
//        stopWatch.stop();
//        System.out.println("total time: " + stopWatch.getTotalTimeSeconds()); //총 얼마나 걸렸는지
        return user; //afterReturning으로
    }

    @Timer //우리가 직접만든 어노테이션
    @DeleteMapping("delete")
    public void delete() throws InterruptedException{ //http://localhost:8080/api/delete 
        //delete하는데 2초 소요된다고 가정

        //aop를 쓰지않으면 이렇게 중복된코드가 들어가는데 get, post에도 마찬가지로 실제적으로 Logic이 들어가는곳에 반복적으로 들어갈수있다.
        //모든 메서드에 같은 기능이 들어갔다(횡단). 비즈니스로직과 전혀상관없는 이러한것들을 aop로 뺴는 것이다. 너네는 서비스로직만 신경써
//        StopWatch stopWatch = new StopWatch();
//        stopWatch.start();
        System.out.println("타이머실행");
        Thread.sleep(1000 * 2);
        System.out.println("타이머종료");
//        stopWatch.stop();
//        System.out.println("total time: " + stopWatch.getTotalTimeSeconds()); //총 얼마나 걸렸는지
    }
}


//출력결과 (여기서는 get,post가 실행되지않음. 요청이 delete로 왔기떄문에)
여기니? :delete
전
타이머실행
타이머종료
후
total time: 2.0212233
return obj:null
=======================================================================================
//aop의 또다른 기능 
반환할 때 aop에서 특정한 객체로 반환해주거나, 암호화된 값이 들어올때 코드에서 복호화하는것이아니라 이미 aop에서 복호화가 된 상태로 들어오게 할 수 있고,
밖으로 내보낼때도 aop단에서 변경할 수있다.

package com.example.aop.dto;

public class User {
    private String id;
    private String pw;
    private String email;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public String getPw() {
        return pw;
    }

    public void setPw(String pw) {
        this.pw = pw;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    @Override
    public String toString() {
        return "User{" +
                "id='" + id + '\'' +
                ", pw='" + pw + '\'' +
                ", email='" + email + '\'' +
                '}';
    }
}
--------------------
//main(이메일 인코딩값얻기위해)
package com.example.aop;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

import java.util.Base64;

@SpringBootApplication
public class AopApplication {

    public static void main(String[] args) {

        SpringApplication.run(AopApplication.class, args);
        System.out.println(Base64.getEncoder().encodeToString("steve@gmail.com".getBytes())); //출력결과를 복사해서 크롬에 c3RldmVAZ21haWwuY29t
    }


}
-----------------------
package com.example.aop.annotation;

import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME) //런타임때 사용
public @interface Decode {

}
-------------------
package com.example.aop.aop;

import com.example.aop.dto.User;
import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.springframework.stereotype.Component;

import java.io.UnsupportedEncodingException;
import java.nio.charset.StandardCharsets;
import java.util.Base64;

@Aspect
@Component
public class DecodeAop {
    @Pointcut("execution(* com.example.aop.controller..*.*(..))")
    private void cut() {}

    @Pointcut("@annotation(com.example.aop.annotation.Decode)")
    private void enableDecode() {}

    //전은 디코드를 해서보낼꺼고
    @Before(("cut() && enableDecode()"))
    public void before(JoinPoint joinPoint) throws UnsupportedEncodingException {
        Object[] args = joinPoint.getArgs();

        for(Object arg : args) {
            if(arg instanceof User) { //arg중에 User가 있으면
                User user = User.class.cast(arg); //현재는 Object이기 떄문에 User로 형변환을 시킨다.
                String base64Email = user.getEmail(); // 인코딩되있는 이메일을
                String email = new String(Base64.getDecoder().decode(base64Email),"UTF-8"); //bytes로 반환 -> String으로

                user.setEmail(email); //디코드된거(이렇게되면 컨트롤러에서는 유저라는 객체를 디코드 할 필요가없어진다)
            }
        }
    }
    //후는 인코드를 해서 보낼거다
    @AfterReturning(value = "cut() && enableDecode()", returning = "returnObj")
    public void afterReturn(JoinPoint joinPoint, Object returnObj) {
        if(returnObj instanceof User) {
            User user = User.class.cast(returnObj); //평문이메일을
            String email = user.getEmail();
            String base64Email = Base64.getEncoder().encodeToString(email.getBytes()); //인코딩
            user.setEmail(base64Email);
        }
    }
}
-----------------------------
package com.example.aop.aop;

import org.aspectj.lang.JoinPoint;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.Pointcut;
import org.aspectj.lang.reflect.MethodSignature;
import org.springframework.stereotype.Component;

import java.lang.reflect.Method;

@Aspect //aop로 동작
@Component //스프링에서 관리
public class ParameterAop {
    //controller하위 메서드가 실행되기전에 before부분이 실행될거고 그 후에 controller 메서드 실행 후 정상리턴되면 afterReturning에서 해당 object를 볼수가있다.
    @Pointcut("execution(* com.example.aop.controller..*.*(..))") //어디에 적용시킬건지(controller패키지밑에 모든 메서드를 aop로 보겠다)
    private void cut() {}

    @Before("cut()") //cut이 실행되는 지점에 before메서드를 실핼
    public void before(JoinPoint joinPoint) {
        MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature();
        Method method = methodSignature.getMethod();
        System.out.println("여기니? :" + method.getName());

        //deletemapping은 여기 실행안됌. 받은 인자가 없어서 -> @AfterReturning으로
        Object[] args = joinPoint.getArgs();
        for(Object obj : args) {
            System.out.println("여기는 실행안되네??");
            System.out.println("type: " + obj.getClass().getSimpleName());
            System.out.println("value: " + obj);

        }
    }

    @AfterReturning(value = "cut()", returning = "returnObj")
    public void afterReturn(JoinPoint joinPoint, Object returnObj) {
        System.out.println("return obj:" + returnObj); //return obj: null (void라서)
    }
}
---------------------------------------
package com.example.aop.controller;

import com.example.aop.annotation.Decode;
import com.example.aop.annotation.Timer;
import com.example.aop.dto.User;
import org.springframework.util.StopWatch;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api")
public class RestApiController {
    @GetMapping("/get/{id}")
    public String get(@PathVariable Long id, @RequestParam String name) {
//        StopWatch stopWatch = new StopWatch();
//        stopWatch.start();
//        //Logic이 들어가는 곳
//        stopWatch.stop();
//        System.out.println("total time: " + stopWatch.getTotalTimeSeconds()); //총 얼마나 걸렸는지
        return id + " " + name;
    }

    @PostMapping("/post")
    public User post(@RequestBody User user) { //크롬에 body에 넣어서
        //http://localhost:8080/api/post
//        {
//            "id" : "steve",
//            "pw" : "1234",
//            "email": "steve@gmail.com"
//        }
//        StopWatch stopWatch = new StopWatch();
//        stopWatch.start();
//        //Logic이 들어가는 곳.
//        stopWatch.stop();
//        System.out.println("total time: " + stopWatch.getTotalTimeSeconds()); //총 얼마나 걸렸는지
        return user; //afterReturning으로
    }

    @Timer //우리가 직접만든 어노테이션
    @DeleteMapping("delete")
    public void delete() throws InterruptedException{
        //delete하는데 2초 소요된다고 가정

        //aop를 쓰지않으면 이렇게 중복된코드가 들어가는데 get, post에도 마찬가지로 실제적으로 Logic이 들어가는곳에 반복적으로 들어갈수있다.
        //모든 메서드에 같은 기능이 들어갔다(횡단). 비즈니스로직과 전혀상관없는 이러한것들을 aop로 뺴는 것이다. 너네는 서비스로직만 신경써
//        StopWatch stopWatch = new StopWatch();
//        stopWatch.start();
        System.out.println("타이머실행");
        Thread.sleep(1000 * 2);
        System.out.println("타이머종료");
//        stopWatch.stop();
//        System.out.println("total time: " + stopWatch.getTotalTimeSeconds()); //총 얼마나 걸렸는지
    }

    @Decode //값을 바꿔줄거기 때문에
    @PutMapping("/put")
    public User put(@RequestBody User user) { // 크롬에 http://localhost:8080/api/put
//        {
//            "id" : "steve",
//            "pw" : "1234",
//            "email" : "c3RldmVAZ21haWwuY29t" //인코딩된 이메일(main에서 출력해서 받아옴)
//        }
        System.out.println("put");
        System.out.println(user); //실제 서비스로직에서는 평문
        return user;
    }
    //출력결과 (처음에 인코딩된 email을 받아서 before에서 디코딩처리하고 setemail -> putmapping api실행 -> user를 after에 전달 -> after에서 인코딩 후 setemail
//    여기니? :put
//    여기는 실행안되네??
//    type: User
//    value: User{id='steve', pw='1234', email='steve@gmail.com'}
//    put
//    User{id='steve', pw='1234', email='steve@gmail.com'}
//    return obj:User{id='steve', pw='1234', email='steve@gmail.com'}

    //크롬에 응답온걸 보면
//    {
//        "id": "steve",
//        "pw": "1234",
//        "email": "c3RldmVAZ21haWwuY29t"
//    }

}
=============================================================================================
//object-mapper를 통해 json노드 접근 , objectmapper자체가 스프링프레임워크에서 사용하는 자바 라이브러리인것이지, objectmapper가 꼭 스프링에서 사용되는 것은 아니다.
그래서 자바로 만들어보자 -> gradle로 만들자.(사진) 이러한 dependencies를 어디서 가져오나? 원래는 maven으로 설정을 해야하는데 우리는 gradle로 활용
jackson databind 라이브러리를 maven repository에서 복사 -> 

// https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind
implementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.12.1'

//이거를 build.gradle에 dependencies {
	부분에 넣어야한다.
}

//확인하는 법은 우측에 gradle 클릭 -> dependencies부분, 또는 좌측에 external Libraries
#)build.gradle
plugins {
    id 'java'
}

group 'org.example'
version '1.0-SNAPSHOT'

repositories {
    mavenCentral()
}

dependencies {
    // https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind
    implementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: '2.12.1'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.8.2'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.8.2'
}

test {
    useJUnitPlatform()
}
--------------------
#)sample.json(참조용)
{
  "name" : "홍길동",
  "age" : 10,
  "cars" : [
    {
      "name" : "K5",
      "car_number" : "11가 1111",
      "TYPE" : ""
    },
    {
      "name" : "Q5",
      "car_number" : "12가 1111",
      "TYPE" : ""
    }
  ]
}
--------------------------
package dto;

import com.fasterxml.jackson.annotation.JsonProperty;

//전체가 스네이크케이스면 여기다가 어노테이션 근데, 지금은 TYPE도 있기떄문에 전체가 스네이크케이스가 아니라서 별도로 설정
public class Car {
    private String name;
    @JsonProperty("car_number")
    private String carNumber;
    @JsonProperty("TYPE")
    private String type;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCarNumber() {
        return carNumber;
    }

    public void setCarNumber(String carNumber) {
        this.carNumber = carNumber;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return "Car{" +
                "name='" + name + '\'' +
                ", carNumber='" + carNumber + '\'' +
                ", type='" + type + '\'' +
                '}';
    }
}
----------------
package dto;

import java.util.List;

public class User {
    private String name;
    private int age;
    private List<Car> cars;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public List<Car> getCars() {
        return cars;
    }

    public void setCars(List<Car> cars) {
        this.cars = cars;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", cars=" + cars +
                '}';
    }
}
----------------------
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ArrayNode;
import com.fasterxml.jackson.databind.node.ObjectNode;
import dto.Car;
import dto.User;

import java.util.Arrays;
import java.util.List;

public class Main {
    public static void main(String[] args) throws JsonProcessingException {
        System.out.println("main");
    
        ObjectMapper objectMapper = new ObjectMapper();

        User user = new User();
        user.setName("홍길동");
        user.setAge(10);

        Car car1 = new Car();
        car1.setName("k5");
        car1.setCarNumber("11가 1111");
        car1.setType("sedan");

        Car car2 = new Car();
        car2.setName("Q5");
        car2.setCarNumber("12가 1111");
        car2.setType("SUV");

        List<Car> carList = Arrays.asList(car1,car2);
        user.setCars(carList);

        //인코딩설정 UTF-8 해야된다. settings, help에서 (사진),안하면 한글깨진다. json의 기본 인코딩이 UTF-8이기 때문에(윈도우에서는 설정해야한다)
        System.out.println(user); //User{name='홍길동', age=10, cars=[Car{name='k5', carNumber='11가 1111', type='sedan'}, Car{name='Q5', carNumber='12가 1111', type='SUV'}]}

        //json으로 바꿔보자
        String json = objectMapper.writeValueAsString(user);
        System.out.println(json); //{"name":"홍길동","age":10,"cars":[{"name":"k5","carNumber":"11가 1111","type":"sedan"},{"name":"Q5","carNumber":"12가 1111","type":"SUV"}]}
        //이렇게 보면 헷갈릴수있으니 크롬에서 json validator가서 붙여넣으면 보기쉽게 나온다.
        //JsonProperty붙인후(Car)
        //{"name":"홍길동","age":10,"cars":[{"name":"k5","car_number":"11가 1111","TYPE":"sedan"},{"name":"Q5","car_number":"12가 1111","TYPE":"SUV"}]}

        //이제 json노드 접근
        JsonNode jsonNode = objectMapper.readTree(json); //여기서jsonNode는 sample.json에 정의한 전체 json을 의미
        String _name = jsonNode.get("name").asText(); //jsonNode.get하면 object가 나오고 거기에 형변환으로 asText
        int _age = jsonNode.get("age").asInt();
        System.out.println("name : " +_name);
        System.out.println("age : " +_age);

        //Cars는 리스트 안에 또다른 jsonnode가 들어있는거나 마찬가지이다. 그래서 cars안에 있는 노드를 가져와야한다.
        JsonNode cars = jsonNode.get("cars");
        ArrayNode arrayNode = (ArrayNode)cars; //(ArrayNode)는 asText와같이 형변환을 위해서

        List<Car> _cars = objectMapper.convertValue(arrayNode, new TypeReference<List<Car>>() {}); //convertValue : object 즉, json을 우리가 원하는 클래스로 변환가능
        //이렇게 하면 arrayNode(object)를 받아서 우리가 원하는 List<Car>라는 타입으로 변환
        System.out.println(_cars); //[Car{name='k5', carNumber='11가 1111', type='sedan'}, Car{name='Q5', carNumber='12가 1111', type='SUV'}]

        //위에 처럼 json을 가져온 후 값이 바꿔보자
        ObjectNode objectNode = (ObjectNode)jsonNode;
        objectNode.put("name","steve");
        objectNode.put("age", 20);

        System.out.println(objectNode.toPrettyString());
//        {
//            "name" : "steve",  //이렇게 바뀐걸볼수있다. 이렇게 objectmapper를 통해서 각각의 jsonnode에 접근가능하다.
//                "age" : 20,
//                "cars" : [ {
//            "name" : "k5",
//                    "car_number" : "11가 1111",
//                    "TYPE" : "sedan"
//        }, {
//            "name" : "Q5",
//                    "car_number" : "12가 1111",
//                    "TYPE" : "SUV"
//        } ]
//        }

    }
}
==================================================================================
//spring boot validation(스프링부트의 기능 중 하나)
validation이란 특히 java에서는 null값에 대해서 접근하려고 할 떄 null pointer exception이 발생함으로, 이러한 부분을 방지하기 위해서 
미리 검증을 하는 과정을 validation이라고 한다.

public void run(String account, String pw, int age) {
	if(account == null || pw == null) {
		return 0;
	}
	...
	정상로직(비즈니스로직)
}

하지만 이게 매개변수가 늘어나고, 객체가 들어오고 하면 코드가 복잡해진다. 비즈니스로직이 잘 안보이게된다.
따라서 service logic과의 분리가 필요하다.

여기서 스프링에서는 일관된 validation이 존재하는데 어노테이션 기반이다.
@Size : 문자길이 측정(int type불가)
@NotNull : null 불가
@NotEmpty : null, ""불가
@NotBlank : null, "", " "불가(띄어쓰기도완됌. 무조건 글자한개이상 들어가야됌)
@Past : 과거날짜
@PastOrPresent : 오늘이거나 과거 날짜
@Future : 미래 날짜
@FutureOrPresent : 오늘이거나 미래 날짜
@Pattern : 정규식 적용(이메일이냐 핸드폰이냐)
@Max : 최대값
@Min : 최소값
@AssertTrue/False : 별도 Logic적용
@Vaild : 해당 object validation 실행

build.gradle에서 dependencies해줘야한다.
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    implementation 'org.springframework.boot:spring-boot-starter-validation'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
-----------------
package com.example.validation.dto;

import javax.validation.constraints.Email;
import javax.validation.constraints.Max;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Pattern;

public class User {
    @NotBlank
    private String name;
    @Max(value = 90)
    private int age;
    @Email //이렇게 하면 main에서 @Valid @RequestBody User user 이렇게 @Valid를 붙여햐한다. 그러면 User를 request할때 email변수에대해서 검사한다.
    private String email;

    @Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "핸드폰 번호의 양식과 맞지 않습니다. 01x-xxx(x)-xxxx") //@Vaild마찬가지
    //@Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$") //@Vaild마찬가지
    private String phoneNumber;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", email='" + email + '\'' +
                ", phoneNumber='" + phoneNumber + '\'' +
                '}';
    }
}

------------------
package com.example.validation.controller;

import com.example.validation.dto.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;

//{
//        "name" : "홍길동",
//        "age" : 10,
//        "email" : "abced",
//        "phoneNumber" : "01011112222"
//}

@RestController
@RequestMapping("/api")
public class ApiController {
    @PostMapping("/user") // http://localhost:8080/api/user
    public User user(@RequestBody User user) {
        //근데 이거는 email이나 phoneNumber가 정상적인 요청이아니다. 이메일은 @가 들어가야하는데 요청이 잘못됌, 나이도 100살이하로 받아야됀다.
        System.out.println(user); //User{name='홍길동', age=120, email='abced', phoneNumber='01011112222'}
        return user;
    }

    //그래서 기존에서는 이렇게 하나씩 if문써서 했다.
    @PostMapping("/user1")
    public ResponseEntity user1(@RequestBody User user) {
        System.out.println(user);
        if(user.getAge() >= 100) {
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(user);
        }
        return ResponseEntity.ok(user);
    }
    //그래서 User class를 참조해보면 validation을 붙힌다.
    @PostMapping("/user2") // http://localhost:8080/api/user
    public User user2(@Valid @RequestBody User user) { //@Valid를 붙인다.
        System.out.println(user);
        return user;
    }

    //이렇게 전송 시
//    {
//            "name" : "홍길동",
//            "age" : 101,
//            "email" : "abced",
//            "phoneNumber" : "01011112222"
//    }
    //근데 클라이언트가 잘못입력 시 지금은 예외가 바로 터지는데 Validation의 결과를 BindingResult으로 들어오게만든후 메시지를 출력해보자
    @PostMapping("/user3") // http://localhost:8080/api/user
    public ResponseEntity user3(@Valid @RequestBody User user, BindingResult bindingResult) { //@Valid를 붙인다.
        if(bindingResult.hasErrors()) {
            StringBuilder sb = new StringBuilder();
            bindingResult.getAllErrors().forEach(objectError -> {
                FieldError field = (FieldError) objectError;
                String message = objectError.getDefaultMessage();

                System.out.println("field :" +field.getField());
                System.out.println(message);
            });
        }
        System.out.println(user);
        return ResponseEntity.ok(user); //client body에 user 객체를 보낸다. (보여주기위해)
        //출력결과
//        field :email
//        올바른 형식의 이메일 주소여야 합니다
//        field :phoneNumber
//        "^\d{2,3}-\d{3,4}-\d{4}$"와 일치해야 합니다
//        User{name='홍길동', age=101, email='abced', phoneNumber='01011112222'}
    }
    //근데 에러 메시지가 예쁘지가 않다. (전화번호) 그래서 User class에서 메시지를 지정해줄도 있다
    @PostMapping("/user4") // http://localhost:8080/api/user
    public ResponseEntity user4(@Valid @RequestBody User user, BindingResult bindingResult) { //@Valid를 붙인다.
        if (bindingResult.hasErrors()) {
            StringBuilder sb = new StringBuilder();
            bindingResult.getAllErrors().forEach(objectError -> {
                FieldError field = (FieldError) objectError;
                String message = objectError.getDefaultMessage();

                System.out.println("field :" + field.getField());
                System.out.println(message);

                sb.append("filed: " + field.getField());
                sb.append("message: " + message);

            });
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(sb.toString());
            //출력결과: filed: phoneNumbermessage: 핸드폰 번호의 양식과 맞지 않습니다. 01x-xxx(x)-xxxxfiled: emailmessage: 올바른 형식의 이메일 주소여야 합니다filed: agemessage: 90 이하여야 합니다
        }
        //여기는 logic부분 이제 쓰면됌

        return ResponseEntity.ok(user); //if문을 돌지않으면 여기로
    }

}

==================================================
//Custom Validation 
@Assert/False와 같은 method지정을 통해서 직접 로직 가능
즉, 커스텀을 통해 재사용이 가능

package com.example.validation.dto;

import javax.validation.constraints.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class User {
    @NotBlank
    private String name;
    @Max(value = 90)
    private int age;
    @Email //이렇게 하면 main에서 @Valid @RequestBody User user 이렇게 @Valid를 붙여햐한다. 그러면 User를 request할때 email변수에대해서 검사한다.
    private String email;

    @Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "핸드폰 번호의 양식과 맞지 않습니다. 01x-xxx(x)-xxxx") //@Vaild마찬가지
    //@Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$") //@Vaild마찬가지
    private String phoneNumber;

    @Size(min = 6, max = 6)
    private String reqYearMonth; // yyyyMM

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public String getReqYearMonth() {
        return reqYearMonth;
    }

    public void setReqYearMonth(String reqYearMonth) {
        this.reqYearMonth = reqYearMonth;
    }

    //커스텀 -> 근데 이거는 다른클래스에서 만약에 재사용할려면 똑같은 코드를 또 써야한다. -> 어노테이션을 만들면 해결됌
    @AssertTrue(message = "yyyyMM 의 형식에 맞지않습니다.")
    public boolean isReqYearMonthValidation() { //AssertTrue를 쓰면 메서드에 꼭 is를 붙여야한다.
        //LocalDate는 기본적으로 yyyyMMdd이기 떄문에 뒤에 01붙힘.(왜냐하면 우리는 6자리로 입력받았기 떄문에)
        //this.reqYearMonth = getReqYearMonth()+"01";
        try {
            LocalDate localDate = LocalDate.parse(getReqYearMonth()+"01", DateTimeFormatter.ofPattern("yyyyMMdd")); //파싱이 잘되면 true
        }catch(Exception e) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", email='" + email + '\'' +
                ", phoneNumber='" + phoneNumber + '\'' +
                ", reqYearMonth='" + reqYearMonth + '\'' +
                '}';
    }
}
-------------------
package com.example.validation.controller;

import com.example.validation.dto.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;

//{
//        "name" : "홍길동",
//        "age" : 10,
//        "email" : "abced",
//        "phoneNumber" : "01011112222"
//}

@RestController
@RequestMapping("/api")
public class ApiController {
    //Custom한 reqYearMonth를 넣어보자. (user class참조)
//    {
//            "name" : "홍길동",
//            "age" : 101,
//            "email" : "abced",
//            "phoneNumber" : "01011112222",
//            "reqYearMonth" : "202204"  이렇게 쓰면 자릿수만 6개 맞으면된다. 하지만, 아무 6자리가 가능하기때문에 날짜로 설정해야한다. -> @AssertTrue
//    }
    @PostMapping("/user5")
    public ResponseEntity user5(@Valid @RequestBody User user, BindingResult bindingResult) { //@Valid를 붙인다.
        if (bindingResult.hasErrors()) {
            StringBuilder sb = new StringBuilder();
            bindingResult.getAllErrors().forEach(objectError -> {
                FieldError field = (FieldError) objectError;
                String message = objectError.getDefaultMessage();

                System.out.println("field :" + field.getField());
                System.out.println(message);

                sb.append("filed: " + field.getField());
                sb.append("message: " + message);

            });
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(sb.toString());

        }
        //여기는 logic부분 이제 쓰면됌

        return ResponseEntity.ok(user); //if문을 돌지않으면 여기로
    }

}
===============================================================================
//커스텀의 재사용을 위해 어노테이션을 만들자

package com.example.validation.dto;

import com.example.validation.annotation.YearMonth;

import javax.validation.constraints.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class User {
    @NotBlank
    private String name;
    @Max(value = 90)
    private int age;
    @Email //이렇게 하면 main에서 @Valid @RequestBody User user 이렇게 @Valid를 붙여햐한다. 그러면 User를 request할때 email변수에대해서 검사한다.
    private String email;

    @Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$", message = "핸드폰 번호의 양식과 맞지 않습니다. 01x-xxx(x)-xxxx") //@Vaild마찬가지
    //@Pattern(regexp = "^\\d{2,3}-\\d{3,4}-\\d{4}$") //@Vaild마찬가지
    private String phoneNumber;

    @YearMonth
    private String reqYearMonth; //입력받을때는 yyyyMM을 입력받는다.

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getPhoneNumber() {
        return phoneNumber;
    }

    public void setPhoneNumber(String phoneNumber) {
        this.phoneNumber = phoneNumber;
    }

    public String getReqYearMonth() {
        return reqYearMonth;
    }

    public void setReqYearMonth(String reqYearMonth) {
        this.reqYearMonth = reqYearMonth;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", email='" + email + '\'' +
                ", phoneNumber='" + phoneNumber + '\'' +
                ", reqYearMonth='" + reqYearMonth + '\'' +
                '}';
    }
}

----------------------
package com.example.validation.annotation;

import com.example.validation.validator.YearMonthValidator;

import javax.validation.Constraint;
import javax.validation.Payload;
import java.lang.annotation.Retention;
import java.lang.annotation.Target;

import static java.lang.annotation.ElementType.*;
import static java.lang.annotation.ElementType.TYPE_USE;
import static java.lang.annotation.RetentionPolicy.RUNTIME;

//@Email내용을 복사하자
@Constraint(validatedBy = {YearMonthValidator.class}) //어떠한 클래스를 가지고 검색할것인가, 우리가 검사를정의했던 YearMonthValidator를 넘기고 그거를 가지고 날짜를 검사해라
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER, TYPE_USE })
@Retention(RUNTIME)
public @interface YearMonth {
    String message() default "yyyyMM의 형식에 맞지 않습니다."; //이렇게해도되고 reqYearMonth 멤버필드에 @YearMonth(message = "~~")해도된다.

    Class<?>[] groups() default { };

    Class<? extends Payload>[] payload() default { };
    //여기까지 디폴트 설정

    //이제부터
    String pattern() default "yyyyMMdd"; //user class에 reqYearMonth에 (pattern = "yyyyMMdd")을 안적을때는 이렇게 해도된다.
    //즉, 실제로는 yyyyMM으로 입력을 받지만 내부에서는 yyyyMMdd로 고쳐지게된다.(YearMonthValidator에서)
}
---------------------------
package com.example.validation.validator;

import com.example.validation.annotation.YearMonth;

import javax.validation.ConstraintValidator;
import javax.validation.ConstraintValidatorContext;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class YearMonthValidator implements ConstraintValidator<YearMonth, String> {
    private String pattern; //yyyyMM

    @Override
    public void initialize(YearMonth constraintAnnotation) {
        this.pattern = constraintAnnotation.pattern(); //어노테이션에 지정된 패턴을 가져온다.
    }

    @Override
    public boolean isValid(String value, ConstraintValidatorContext context) {
        try { //User class의 @AsserTrue뺴도된다.
            //LocalDate는 dd가 있어야하기때문에 임의적으로 01을 붙혀서 검색(날짜가 유효한지) 1일은 모든 달에 들어있으니
            LocalDate localDate = LocalDate.parse(value+"01", DateTimeFormatter.ofPattern(this.pattern)); //파싱이 잘되면 true
        }catch(Exception e) {
            return false;
        }
        return true;

    }
}
--------------------------
package com.example.validation.controller;

import com.example.validation.dto.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;


@RestController
@RequestMapping("/api")
public class ApiController {

    //Custom한 reqYearMonth를 넣어보자. (user class참조)
//    {
//            "name" : "홍길동",
//            "age" : 101,
//            "email" : "abced",
//            "phoneNumber" : "01011112222",
//            "reqYearMonth" : "202204"  이렇게 쓰면 자릿수만 6개 맞으면된다. 하지만, 아무 6자리가 가능하기때문에 날짜로 설정해야한다.
//    }
    @PostMapping("/user5")
    public ResponseEntity user5(@Valid @RequestBody User user, BindingResult bindingResult) { //@Valid를 붙인다.
        if (bindingResult.hasErrors()) {
            StringBuilder sb = new StringBuilder();
            bindingResult.getAllErrors().forEach(objectError -> {
                FieldError field = (FieldError) objectError;
                String message = objectError.getDefaultMessage();

                System.out.println("field :" + field.getField());
                System.out.println(message);

                sb.append("filed: " + field.getField());
                sb.append("message: " + message);

            });
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(sb.toString());

        }
        //여기는 logic부분 이제 쓰면됌

        return ResponseEntity.ok(user); //if문을 돌지않으면 여기로
    }

}
======================================================================================
package com.example.validation.dto;

import com.fasterxml.jackson.annotation.JsonProperty;

import javax.validation.constraints.NotBlank;

//전체가 스네이크케이스면 여기다가 어노테이션 근데, 지금은 TYPE도 있기떄문에 전체가 스네이크케이스가 아니라서 별도로 설정
public class Car {
    @NotBlank
    private String name;

    @NotBlank
    @JsonProperty("car_number")
    private String carNumber;

    @NotBlank
    @JsonProperty("TYPE")
    private String type;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getCarNumber() {
        return carNumber;
    }

    public void setCarNumber(String carNumber) {
        this.carNumber = carNumber;
    }

    public String getType() {
        return type;
    }

    public void setType(String type) {
        this.type = type;
    }

    @Override
    public String toString() {
        return "Car{" +
                "name='" + name + '\'' +
                ", carNumber='" + carNumber + '\'' +
                ", type='" + type + '\'' +
                '}';
    }
}
---------------------
package com.example.validation.dto;

import com.example.validation.annotation.YearMonth;

import javax.validation.Valid;
import javax.validation.constraints.*;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class User {
    @NotBlank
    private String name;
    @Max(value = 90)
    private int age;

    @Valid
    private List<Car> cars;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public List<Car> getCars() {
        return cars;
    }

    public void setCars(List<Car> cars) {
        this.cars = cars;
    }

    @Override
    public String toString() {
        return "User{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", cars=" + cars +
                '}';
    }
}
---------------
package com.example.validation.controller;

import com.example.validation.dto.User;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.BindingResult;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import javax.validation.Valid;

    //요청을 속성에 공백을 줘서 했는데 200 정상 뜨네?? -> User class에 List<Car>에 @Valid를 붙여야한다.
//    {
//        "name" : "홍길동",
//            "age" : 10,
//            "cars" : [
//        {
//                "name" : "K5",
//                "car_number" : "",
//                "TYPE" : ""
//        },
//        {
//                "name" : "Q5",
//                "car_number" : "",
//                "TYPE" : ""
//        }
//  ]
//    }
    @PostMapping("/user5")
    public ResponseEntity user5(@Valid @RequestBody User user, BindingResult bindingResult) { //@Valid를 붙인다.
        if (bindingResult.hasErrors()) {
            StringBuilder sb = new StringBuilder();
            bindingResult.getAllErrors().forEach(objectError -> {
                FieldError field = (FieldError) objectError;
                String message = objectError.getDefaultMessage();

                System.out.println("field :" + field.getField());
                System.out.println(message);

                sb.append("filed: " + field.getField());
                sb.append("message: " + message);

            });
            return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(sb.toString());

        }
        //여기는 logic부분 이제 쓰면됌

        return ResponseEntity.ok(user); //if문을 돌지않으면 여기로
    }

}
=============================================================



























