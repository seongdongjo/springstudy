객체 지향 특성 - 추상화, 상속, 은닉, 재사용, 인터페이스 등

1. 캡슐화 : 객체의 속성을 보호하기위해사용 - getter,setter, crud메서드 등
- 장점 : 실제로 method가 어떻게 동작하는지 외부에서는 이해할 필요가없다. 
       재사용성 향상
	   유지보수 향상(하나의 객체안의 속성을 바꿔도 다른곳에는 영향x)
       무결성(변수는 private, 함수는 public)
2. 상속
- 최상위 클래스만 보고 하위클래스들이 어떤한 속성을 가지는지 확인 가능
- 재사용성 향상(상속받아서 사용)
- 유지보수 향상

3. 다형성(오버라이딩을 통해 알아서 찾아간다.)
4. 추상화(객체지향에서의 추상화는 모델링이다)

----------
객체지향설계 5원칙(SOLID)

결합도는 낮추고 응집도는 높여야한다.
결합도는 클래스간의 상호의존정도를 나타내는지표이다.
결합도가 낮으면 모듈(클래스)간의 상호의존성이 줄어들어서 객체 재사용 및 유지보수가 유리하다.

응집도는 모듈내부에서 구성요소들의 기능관련적으로 응집도가 높아야한다.

1. SRP(단일책임원칙)
//객체지향, 다형성 적용안시킬때
//이렇게 하면 유닛이 늘어나면 계속 else if써야되고 혹시나 잘못설정하면 move전체 메서드에 영향을 주게 된다.(단일책임)
class Unit {
	private String name,
	private int speed,
	
	public void attack() {
	}
	
	public void move() {
		if(name.equals("저글링")) {
			speed += 3
		}else if(name.equals("탱크")) {
			if("탱크모드") {
				speed = 0
			}else {
				speed = 10
			}
		}
	}
}

-----------------
//올바른 예 -> 각 기능을 분리함
class 저글링 extends Unit {
	public void move() {
		this.speed += 3
	}
}

class 탱크 extends Unit {
	public void move() {
		if("탱크모드") {
		
		}else {
		
		}
	}
}

class 정찰기 extends Unit {
	public void 정찰기() {
		this.충돌 = false;
	}
	public void move() {
		speed = 15
	}
}
===========================================================
2. OCP(개방폐쇄원칙)
- 자신의 확장에는 열려있고, 주변의 변화에 대해서는 닫혀있어야한다.(jdbc)
가운데에 jdbc인터페이스를 두고 바깥에는 oracle, mysql, h2, mariadb 등으로 확장가능
- 예를들어, java프로그램은 어떤 운영체제에서도 JVM을 통해 동일하게 실행된다.(java는 OS에 개방적이다)
- 다르게 표현하면, java프로그램언어는 운영체제가 변경되더라도 영향을 받지 않는다.
(java는 OS변경에 영향을 받지않는다. OS변경에 닫혀있다)

- 또 예를들어, Jdbc는 데이터 커넥션 부분만 변경하면, 어떤 dB에서도 동일하게 사용할 수 있다.(JDBC는 db에 개방적이다)
- 다르게 표현하면, jdbc는 db가 중간에 변경되더라도 영향을 받지 않게 설계되어 있다.
(jdbc는 db의 변경에 닫혀있다)

- 또 예를들어, 나는 자동차 운전을 할 수 있다. 소나타, 그랜저, bmw 등
(나는 자동차 운전에 개방적이다)
- 다르게 표현하면, 나는 자동차가 바뀌더라도 영향을 받지 않는다.
- 즉 자동차가 바뀌더라도 내가 운전하는 방식은 동일해야한다.

//잘못된 예
운전자--- 소나타(method운전하다())
운전자--- 그랜저(method운전하다())
운전자--- BMW(method운전하다())

//올바른 예
운전자 ---- 자동차(method운전하다())
           |
		---|--------------
		|  		 |    	 |
	  소나타 		그랜저 	BMW
    (override   (override)   
  method운전하다()) 운전하다()

//잘못된 예
package book.oopforsprings.lec05.solid;

public class OCP운전자_NO {

	public static void main(String[] args) {
		// TODO Auto-generated method stub
		
		소나타2 운전자 = new 소나타2();
		  운전자.drive();
		
		그랜저2 운전자2 = new 그랜저2();
		  운전자2.drive();
		
		BMW2 운전자3 = new BMW2();
		  운전자3.drive();
	}

}

class 소나타2{	
	void drive() {
		System.out.println("나는 소나타를 운전한다.");
	}
}

class 그랜저2{	
	void drive() {
		System.out.println("나는 그랜저를 운전한다.");
	}
}

class BMW2{	
	void drive() {
		System.out.println("나는 BMW를 운전한다.");
	}
}

//올바른 예(확장이 쉽게)
package book.oopforsprings.lec05.solid;

public class OCP운전자_OK {

	public static void main(String[] args) {
		
		자동차[] 운전자 = new 자동차[3];
		
		운전자[0] = new 소나타();
		운전자[1] = new 그랜저();
		운전자[2] = new BMW();
		
		for(int i=0; i<운전자.length; i++) {
			운전자[i].drive();
		}

	}

}

class 자동차{
	String myCar="자동차";
	void drive() {
		System.out.printf("나는 %s 를 운전할 수 있다. \n",  myCar);
	}
}

class 소나타 extends 자동차{
	public 소나타() {
		myCar = "소나타";
	}	
}

class 그랜저 extends 자동차{	
	public 그랜저() {
		myCar = "그랜저";
	}
}

class BMW extends 자동차{	
	public BMW() {
		myCar = "BMW";
	}
}

  
3. LSP(리스코프치환원칙)
- 서브타입은 언제나 자신의 기반(상위)타입으로 교체할 수있어야한다.

//LSP 위반 예시
       아반떼
	  /   \
    소나타  그렌저

//LSP 적용 예시
	   공중유닛/비행기
	  /         \
	정찰기		   수송기

4. ISP(인터페이스 분리원칙)
-프로젝트 요구사항과 설계에 따라서 SRP, ISP를 선택한다.
예) 지도에는 도보안내, 자동차안내, 바이크안내 등등의 메서드가 있는데 자전거내비는 자전거길안내메서드만 있으면 되는데 그거 하나 쓰겠다고 지도를 상속받으면 필요없는 메서드까지 사용하게될수있다.
그래서, 각 인터페이스를 만들고(자동차길안내, 자전거길안내 등) 자전거내비는 자전거길안내만 할수있게끔 하는게 인터페이스 분리원칙이다.  

5. DIP(의존역전원칙)
===============================================================
POJO JAVA
- 순수한 자바 오브젝트를 뜻한다.
1. 특정 규약에 종속되지 않는다.
특정 라이브러리, 모듈에서 정의된 클래스를 상속받아서 구현하지 않아도 된다.
POJO가 되기 위해서는 외부의 의존성을 두지않고, 순수한 JAVA로 구성이 가능해야한다.

2. 특정 환경에 종속되지 않는다.
http request, session 등 POJO를 위배한것으로 간주
@Annotation 기반으로 설정하는 부분도 엄연히 POJO 라고 볼수는 없다.

POJO Framework
- spring, Hibernate
POJO를 지향하는 프레임워크이다.
개발자가 서비스 로직에 집중하고 이를 POJO로 쉽게 개발할수있도록 지원하고있다.

====================================================================
//디자인패턴
자주 사용하는 설계 패턴을 정형화해서 이를 유형별로 가장 최적의 방법으로 개발을 할 수 있도록 정해둔 설계
-싱글톤패턴
하나의 프린터를 연결할 때(동일한 객체를 얻는다)
package com.company.singleton;

public class AClazz {
    private SocketClient socketClient;

    public AClazz() { //기본생성자
        this.socketClient = SocketClient.getInstance();
        //this.socketClient = new SocketClient(); 이렇게하면 새로운객체만듬
    }
    public SocketClient getSocketClient() {
        return this.socketClient;
    }
}
--------------
package com.company.singleton;

public class BClazz {
    private SocketClient socketClient;

    public BClazz() { //기본생성자
        this.socketClient = SocketClient.getInstance();
    }
    public SocketClient getSocketClient() {
        return this.socketClient;
    }
---------------
package com.company.singleton;

public class SocketClient {
    private static SocketClient socketClient = null;

    //public socketClient() { 이렇게 새로 객체를 만들면 서로 객체가다르다 AClazz참조
    //}
    private SocketClient() { //기본생성자 막고

    }

    public static SocketClient getInstance() { //최초에 한번만 생성
        if(socketClient == null) {
            socketClient = new SocketClient();
        }
        return socketClient;
    }

    public void connect() {
        System.out.println("connect");
    }
------------------
package com.company;

import com.company.adapter.*;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

public class Main {

    public static void main(String[] args) {
        AClazz aClazz = new AClazz();
        BClazz bClazz = new BClazz();

        SocketClient aClient = aClazz.getSocketClient();
        SocketClient bClient = bClazz.getSocketClient();

        System.out.println("두개의 객체가 동일한가");
        System.out.println(aClient.equals(bClient));

    }

}
====================================================================================
-어댑터 패턴
호환성이 없는 기존 클래스의 인터페이스를 변환하여 재사용 할 수 있도록 한다.
OCP(개방퍠쇄원칙)을 따른다.

package com.company.adapter;

public interface Electronic110V {
    void powerOn();
}
-------------
package com.company.adapter;

public interface Electronic220V {
    void connect();
}
--------------
package com.company.adapter;

public class AirConditioner implements Electronic220V{
    @Override
    public void connect() {
        System.out.println("에어컨 220V");
    }
}
----------------
package com.company.adapter;

public class Cleaner implements Electronic220V{
    @Override
    public void connect() {
        System.out.println("청소기 220V");
    }
}
---------------
package com.company.adapter;

public class HairDryer implements Electronic110V{
    @Override
    public void powerOn() {
        System.out.println("헤어드라이기 110V");
    }
---------------
package com.company.adapter;

public class SocketAdapter implements Electronic110V{ //110을 220으로 변환하는 어댑터

    private Electronic220V electronic220V;

    public SocketAdapter(Electronic220V electronic220V) { //생성자
        this.electronic220V = electronic220V;
    }

    @Override
    public void powerOn() {
        electronic220V.connect();
    }
------------------
package com.company;

import com.company.adapter.*;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

public class Main {

    public static void main(String[] args) {
     
        HairDryer hairDryer = new HairDryer();
        connect(hairDryer); //출력: 헤어드라이어 110V

        Cleaner cleaner = new Cleaner();
        //connect(cleaner); 이렇게하면에러가난다. 현재 connect메서드는 110V만 연결가능하다.
        //그래서 어댑터가 필요.(220 -> 110v로 바꿔주는)

        Electronic110V adapter = new SocketAdapter(cleaner); //220v을 어댑터를 통해 연결
        connect(adapter);
        //인터페이스가 서로달라서 맞추지못할때(110,220v) 중간에서 어댑터클래스를 통해 연결 -> 어댑터 패턴

        AirConditioner airConditioner = new AirConditioner();
        Electronic110V airAdapter = new SocketAdapter(airConditioner);
        connect(airAdapter); //에어컨 220V
        
    }
    //콘센트
    //main함수가 static이니까 여기도 static
    public static void connect(Electronic110V electronic110V) {
        electronic110V.powerOn();
    }

}
====================================================================================
//프록시패턴
package com.company.proxy;

public interface IBrowser {
    Html show();
}
---------------
package com.company.proxy;

public class Html {
    private String url;

    public Html(String url) { //생성자
        this.url = url;
    }
}
---------------
package com.company.proxy;

public class Browser implements IBrowser{
    private String url;
    
    public Browser(String url){
        this.url = url;
    }

    @Override
    public Html show() {
        System.out.println("browser loading html from: " + url);
        return new Html(url); //url접근시 html파일만들어서 반환
    }
}
-------------------
package com.company.proxy;

public class BrowserProxy implements IBrowser{
    private String url;
    private Html html;

    public BrowserProxy(String url) {
        this.url = url;
    }

    @Override
    public Html show() {
        if(html == null) {
            this.html = new Html(url);
            System.out.println("BrowserProxy loading html from: " + url);
        }

        System.out.println("BrowserProxy use cache html: " + url);
        return html;
    }
}
------------------
package com.company.aop;

import com.company.proxy.Html;
import com.company.proxy.IBrowser;

public class AopBrowser implements IBrowser {
    private String url;
    private Html html;
    private Runnable before;
    private Runnable after;

    public AopBrowser(String url, Runnable before, Runnable after) {
        this.url = url;
        this.before = before;
        this.after = after;
    }

    //Aop는 관점기준이라 before,after로 비슷하게 해봄
   @Override
    public Html show() {
       before.run(); //전후로 내가 원하는 기능넣을것이다.

       if(html == null) {
           this.html = new Html(url);
           System.out.println("AopBrowser html loading from: " + url);
           try {
               Thread.sleep(1500);
           } catch (InterruptedException e) {
               e.printStackTrace();
           }
       }
       after.run();
       System.out.println("AopBrowser html cache: " +url);
       return html;
    }
}
--------------------------
package com.company;

import com.company.adapter.*;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

public class Main {

    public static void main(String[] args) {

        Browser browser = new Browser("www.naver.com");
        browser.show(); //html파일하나 받는다. 출력: browser loading html from : www.naver.com
        browser.show();
        browser.show();
        browser.show(); //캐시를 사용안하면 새로 계속 html을 생성한다.

        //프록시를 통해호출
        IBrowser browser1 = new BrowserProxy("www.naver.com"); //처음은 html을 생성
        browser.show(); //여기서부터는 cache를 이용함
        browser.show();
        browser.show();
        browser.show();
        browser.show();

		AtomicLong start = new AtomicLong();
        AtomicLong end = new AtomicLong();
        IBrowser aopBrowser = new AopBrowser("www.naver.com",
                () -> {
                    System.out.println("before");
                    start.set(System.currentTimeMillis());
                },
                () -> {
                    long now = System.currentTimeMillis();
                    end.set(now - start.get()); //몇초걸렸는지 end에 들어간다.
                }

        );
        aopBrowser.show(); //처음에는 생성쪽에 1.5초 delay줬으니 1.5초걸리고
        System.out.println("loading time: " + end.get());

        aopBrowser.show(); //두번쨰 호출부터는 loadingtime이 0이다.
        System.out.println("loading time: " + end.get());

    }

}
===============================================================================
//데코레이터 패턴 : 기존 뼈대(클래스)는 유지하되, 이후필요한 형태로 꾸밀 때 사용
ex)커피원액에 물을 넣으면 아메리카노, 거기에 우유를 넣으면 라떼 ...
즉, 원본을 유지하되 첨가되는거
package com.company.decorator;

public interface ICar {
    int getPrice();
    void showPrice(); //금액을 출력
}

--------------
package com.company.decorator;

public class Audi implements ICar{

    private int price;

    public Audi(int price) {
        this.price = price;
    }
    @Override
    public int getPrice() {
        return price;
    }

    @Override
    public void showPrice() {
        System.out.println("audi 의 가격은 "+this.price+"원 입니다.");
    }
}
--------------
package com.company.decorator;

public class A3 extends AudiDecorator{
    public A3(ICar audi, String modelName) {
        super(audi, modelName, 1000);
    }
}
---------------
package com.company.decorator;

public class A4 extends AudiDecorator{
    public A4(ICar audi, String modelName) {
        super(audi, modelName, 2000);
    }
}
-----------------
package com.company.decorator;

public class A5 extends AudiDecorator{
    public A5(ICar audi, String modelName) {
        super(audi, modelName, 3000);
    }
}
------------------
package com.company.decorator;

public class AudiDecorator implements ICar{ //a3,a4,a5에게 전달받음
    protected ICar audi;
    protected String modelName;
    protected int modelPrice;

    public AudiDecorator(ICar audi, String modelName, int modelPrice) {
        this.audi = audi;
        this.modelName = modelName;
        this.modelPrice = modelPrice;
    }

    @Override
    public int getPrice() {
        return audi.getPrice() + modelPrice;
    }

    @Override
    public void showPrice() {
        System.out.println(modelName + "의 가격은"+getPrice()+"원 입니다."); //getPrice는 audi + model가격
    }
}
---------------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {

        ICar audi = new Audi(1000);
        audi.showPrice();

        //등급에따라 가격이 증가
        //a3
        ICar audi3 = new A3(audi, "A3");
        audi3.showPrice();
        //a4
        ICar audi4 = new A4(audi, "A4");
        audi4.showPrice();
        //a5
        ICar audi5 = new A5(audi, "A5");
        audi5.showPrice();

    }
}
===========================================================================
//옵저버 패턴: 변화가 일어났을떄, 미리 등록된 이벤트를 다른 클래스에 통보해주는 패턴을 구현하는 것이다.(event listener에서 해당패턴을 사용하고있다)
ex)교실에서 망을보다가 선생님오시면 이벤트전달해주는 역할

package com.company.observer;

public interface IButtonListener {
    void clickEvent(String event);
}
------------
package com.company.observer;

public class Button {
    private String name;
    private IButtonListener buttonListener;

    public Button(String name) { //1
        this.name = name;
    }
    public void click(String message) { //3
        buttonListener.clickEvent(message);
    }
    public void addListener(IButtonListener buttonListener) { //2
        this.buttonListener = buttonListener;
    }
}
--------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {

        Button button = new Button("버튼");

        button.addListener(new IButtonListener() { //익명클래스
            @Override
            public void clickEvent(String event) {
                System.out.println(event);
            }
        });

        button.click("메시지 전달: click1"); //이벤트를 위에 전달해주는
        button.click("메시지 전달: click2");
        button.click("메시지 전달: click3");
        button.click("메시지 전달: click4");

    }
}
============================================================================
//퍼싸드 패턴
	client
/  		|     \
ftp writer reader

이거를

	  client
	    |
	  facade
/  		|     \
ftp writer reader


//퍼싸드 적용 전 예시
package com.company.facade;

public class Ftp {
    private String host;
    private int port;
    private String path;

    public Ftp(String host, int port, String path) {
        this.host = host;
        this.port = port;
        this.path = path;
    }
    public void connect() {
        System.out.println("FTP Host: " + host + "Port : " +port+ "로 연결합니다.");
    }
    public void moveDirectory() {
        System.out.println("FTP path: " + path+"로 이동합니다.");
    }
    public void dicConnect() {
        System.out.println("FTP 연결을 종료합니다.");
    }
}

-----------------
package com.company.facade;

public class Writer { //파일쓰기
    private String fileName;
    
    public Writer(String fileName) {
        this.fileName = fileName;
    }
    
    public void fileConnect() { //파일 생성또는 이어쓰기
        String msg = String.format("Writer %s로 연결합니다.",fileName);
        System.out.println(msg);
    }
    
    public void fileDisconnect() {
        String msg = String.format("Writer %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
    
    public void write() {
        String msg = String.format("Writer %s로 파일쓰기를 합니다.",fileName);
        System.out.println(msg);
    }
}
--------------------
package com.company.facade;

public class Reader { //파일에서 읽어오기때문에 파일이름을 알아야한다.
    private String fileName;

    public Reader(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Reader %s로 연결합니다.",fileName);
        System.out.println(msg);
    }

    public void fileRead() {
        String msg = String.format("Reader %s의 내용을 읽어옵니다.",fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Reader %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
}
----------------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.facade.Ftp;
import com.company.facade.Reader;
import com.company.facade.Writer;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {
        Ftp ftpClient = new Ftp("www.foo.co.kr", 22, "/home/etc");
        ftpClient.connect();
        ftpClient.moveDirectory();

        Writer writer = new Writer("text.tmp");
        writer.fileConnect();
        writer.write();

        Reader reader = new Reader("text.tmp");
        reader.fileConnect();
        reader.fileRead();

        reader.fileDisconnect();
        writer.fileDisconnect();
        ftpClient.dicConnect();
    }
}
===============================================================================
//퍼싸드 적용 후 예시
package com.company.facade;

public class Ftp {
    private String host;
    private int port;
    private String path;

    public Ftp(String host, int port, String path) {
        this.host = host;
        this.port = port;
        this.path = path;
    }
    public void connect() {
        System.out.println("FTP Host: " + host + "Port : " +port+ "로 연결합니다.");
    }
    public void moveDirectory() {
        System.out.println("FTP path: " + path+"로 이동합니다.");
    }
    public void dicConnect() {
        System.out.println("FTP 연결을 종료합니다.");
    }
}

-----------------
package com.company.facade;

public class Writer { //파일쓰기
    private String fileName;
    
    public Writer(String fileName) {
        this.fileName = fileName;
    }
    
    public void fileConnect() { //파일 생성또는 이어쓰기
        String msg = String.format("Writer %s로 연결합니다.",fileName);
        System.out.println(msg);
    }
    
    public void fileDisconnect() {
        String msg = String.format("Writer %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
    
    public void write() {
        String msg = String.format("Writer %s로 파일쓰기를 합니다.",fileName);
        System.out.println(msg);
    }
}
--------------------
package com.company.facade;

public class Reader { //파일에서 읽어오기때문에 파일이름을 알아야한다.
    private String fileName;

    public Reader(String fileName) {
        this.fileName = fileName;
    }

    public void fileConnect() {
        String msg = String.format("Reader %s로 연결합니다.",fileName);
        System.out.println(msg);
    }

    public void fileRead() {
        String msg = String.format("Reader %s의 내용을 읽어옵니다.",fileName);
        System.out.println(msg);
    }

    public void fileDisconnect() {
        String msg = String.format("Reader %s로 연결 종료합니다.",fileName);
        System.out.println(msg);
    }
}
----------------------
package com.company.facade;

public class SftpClient {
    private Ftp ftp;
    private Reader reader;
    private Writer writer;

    public SftpClient(Ftp ftp, Reader reader, Writer writer) { //두가지방법
        this.ftp = ftp;
        this.reader = reader;
        this.writer = writer;
    }
    //오버로딩
    public SftpClient(String host, int port, String path, String fileName) {
        this.ftp = new Ftp(host,port,path);
        this.reader = new Reader(fileName);
        this.writer = new Writer(fileName);
    }

    public void connect() {
        ftp.connect();
        ftp.moveDirectory();
        writer.fileConnect();
        reader.fileConnect();
    }
    public void disConnect() {
        writer.fileDisconnect();
        reader.fileDisconnect();
        ftp.dicConnect();
    }

    public void read() {
        reader.fileRead();
    }
    public void write() {
        writer.write();
    }
}
------------------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.facade.Ftp;
import com.company.facade.Reader;
import com.company.facade.Writer;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {
        Ftp ftpClient = new Ftp("www.foo.co.kr", 22, "/home/etc");
        ftpClient.connect();
        ftpClient.moveDirectory();

        Writer writer = new Writer("text.tmp");
        writer.fileConnect();
        writer.write();

        Reader reader = new Reader("text.tmp");
        reader.fileConnect();
        reader.fileRead();

        reader.fileDisconnect();
        writer.fileDisconnect();
        ftpClient.dicConnect();
		
	   SftpClient sftpClient = new SftpClient("www.foo.co.kr", 22, "/home/etc", "text.tmp");
       sftpClient.connect();
       sftpClient.write();
       sftpClient.read();
       sftpClient.disConnect();
       //객체들의 의존을 숨기는게 퍼싸드패턴이다.
    }
}
===================================================================================
//전략패턴
유사한 행위들을 캡슐화하여, 객체의 행위를 바꾸고 싶은 경우 직접 변경하는 것이 아닌 전략만 변경하여, 유연하게 확장하는 패턴
package com.company.strategy;

public interface EncodingStrategy {
    String encode(String text);
}
------------
package com.company.strategy;

public class AppendStrategy implements EncodingStrategy{

    @Override
    public String encode(String text) {
        return "ABCD" + text; //abcd를 추가시키는
    }
}
--------------
package com.company.strategy;

import java.nio.charset.StandardCharsets;
import java.util.Base64;

public class Base64Strategy implements EncodingStrategy{

    @Override
    public String encode(String text) {
        return Base64.getEncoder().encodeToString(text.getBytes()); //인코딩하기
    }
}
---------------
package com.company.strategy;

public class Encoder { //그떄그때마다 전략을 받아야한다. 어떤 인코드를 쓸지
    private EncodingStrategy encodingStrategy; //인터페이스

    public String getMessage(String message) {
        return this.encodingStrategy.encode(message);
    }

    public void setEncodingStrategy(EncodingStrategy encodingStrategy) {
        this.encodingStrategy = encodingStrategy;
    }
}
-----------------
package com.company.strategy;

public class NormalStrategy implements EncodingStrategy{
    @Override
    public String encode(String text) {
        return text;
    }
}
----------------
package com.company;

import com.company.adapter.*;
import com.company.aop.AopBrowser;
import com.company.decorator.*;
import com.company.facade.Ftp;
import com.company.facade.Reader;
import com.company.facade.SftpClient;
import com.company.facade.Writer;
import com.company.observer.Button;
import com.company.observer.IButtonListener;
import com.company.proxy.Browser;
import com.company.proxy.BrowserProxy;
import com.company.proxy.IBrowser;
import com.company.singleton.AClazz;
import com.company.singleton.BClazz;
import com.company.singleton.SocketClient;
import com.company.strategy.*;

import java.util.concurrent.atomic.AtomicLong;

public class Main {

    public static void main(String[] args) {


        //전략 메서드를 가진 전략객체(NormalStrategy, Base64Strategy)
        //전략 객체를 사용하는 컨텍스트(Encoder)
        //전략 객체를 생성해 컨텍스트에 주입하는 클라이언트(main)

        Encoder encoder = new Encoder();

        //base64전략 생성
        EncodingStrategy base64 = new Base64Strategy();

        //normal전략생성
        EncodingStrategy normal = new NormalStrategy();

        String message = "hello java";
        //전략수정(원본객체는 그대로 두고)
        encoder.setEncodingStrategy(base64);
        String base64Result = encoder.getMessage(message);
        System.out.println(base64Result); //출력: aGVsbG8gamF2YQ==

        encoder.setEncodingStrategy(normal);
        String normalResult = encoder.getMessage(message);
        System.out.println(normalResult); //출력: hello java

        encoder.setEncodingStrategy(new AppendStrategy());
        String appendResult = encoder.getMessage(message);
        System.out.println(appendResult); //출력: ABCDhello java
    }
}
=========================================================================
//rest : 클라이언트<--> 서버 통신방식
- uri와 http를 이용한, 통신목적의 아키텍처 스타일(유형)
- 아키텍처 스타일이란
EX)클라이언트/서버
   저장소
   파이프/필터
   rest
   
//restful은 rest가 적용된 시스템이다.
//rest api 는 rest가 적용된 api이다.
//rest api를 제공하는 시스템은 restful이다.
rest라는 개념은 6가지 조건을 만족해야한다.
1. 일관된인터페이스
2. 클라이언트/서버(클라이언트는 서버에 요청 메시지를 전송하고 서버는 요청에 대한 응답메시지를 전송한다)
3. 비연결성(세션 등 이전상황 없이도 통신 할 수 있다)
4. 서버의 응답 메시지는 캐싱(저장 후 재사용) 될 수 있다.
5. 계층화된 시스템(계층별로 기능이 분리된다. 중간계층의 기능(로드밸런싱, 서버 증설 , 인증시스템도입등)이 변경되어도 통신에 영향을 주지 않는다.
6. 주문형 코드(option) 손쉬운 데이터 처리를 위해 서버는 클라이언트에서 실행될 스크립트를 전송할 수 있다.

-----------------
URI는 인터넷에서 특정 자원을 나타내는 주소값이다. 유일한 값이다.
요청: https://~~or.kr/resource/sample/1
URL : 특정파일이 어디에 위치하는지 식별하는 주소.
요청: https://~or.kr/ex01.pdf

URL은 URI의 하위개념이다.

URI설계원칙은
1. /를 사용해 계층관계 표현
2. 마지막에는 /를 포함하지않는다.
3. 하이픈(-)은 URI 가독성을 높이는데 사용한다.
https://~~/web-browser
4. 밑줄(_)은 사용하지 않는다
5. 소문자가 적합
6. URI에는 파일확장자를 포함하지 않는다.
7. 프로그래밍언어에 의존적인 확장자를 사용하지않는다.
https://~~/web-master.do
8. 구현에 의존적인 경로를 사용하지 않는다.
https://~~/servlet/~
9. CRUD 기능을 나타내는 것은 URI에 사용하지 않는다.
https://~~/100/READ(X)

--------------------------
HTTP는 TCP기반으로 한 REST의 특징을 모두 구현하고 있는 Web 기반의 프로토콜이다.
====================================================================
스프링부트는 톰캣을 내장하고있기 때문에 따로 설치할 필요 없다.
spring에서 불편한 설정이 없어졌다. (xml설정등)
jar로 패키징되기 떄문에 java가 깔린곳이면 어디든 jar파일을 java어플리케이션 실행가능

//Rest client 설치하기(테스트하기위해)
구글 - 웹스토어(크롬에서 동작하는 앱) 검색 - rest api client 검색 - 밑에 Talend API Tester 다운 - 확장프로그램 실행 (상단 퍼즐모양)

//만약에 톰캣 포트번호를 바꾸고 싶으면 resource - application.properties에 가서 server.port=9090 으로 수정 후 실행하면 9090으로 바뀐걸 볼수있다.
package com.example.hello.Controller;

import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

@RestController //해당 Class는 Rest API를 처리하는 Controller로 등록이된다.
@RequestMapping("/api") //RequestMapping은 URI를 지정해주는 어노테이션이다.
public class ApiController {

    @GetMapping("/hello") //http://localhost:8080/api/hello 이렇게 요청이오면 return보내라
    public String hello() {
        return "hello spring boot";
    }
}
==============================================================================
